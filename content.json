[{"title":"三角形牧场(待批阅)","date":"2018-08-21T13:36:00.000Z","path":"2018/08/21/Triangle-pasture/","text":"Problem 问题描述 和所有人一样，奶牛喜欢变化。它们正在设想新造型的牧场。奶牛建筑师Hei想建造围有漂亮白色栅栏的三角形牧场。她拥有N(3≤N≤40)块木板，每块的长度Li(1≤Li≤40)都是整数，她想用所有的木板围成一个三角形使得牧场面积最大。 请帮助Hei小姐构造这样的牧场，并计算出这个最大牧场的面积。 Analysis 三角形面积立马就想到了海伦公式，所以只需要找到三条边的长度就可以了。 首先考虑当前状态，假设当前选到第i块木板。 我们应该更新什么状态？ 更新面积是不可能的，所以只可能更新木板长度，但是由于木板长度对于面积的影响不确定，所以肯定也不是单单记录当前木板长度，那就只能记录当前木板长度是否可行。 dp[i][j][k]=max(dp[i-1][j-a[i]][k],dp[i-1][j][k-a[i]]) 判断用1-i块木板能否组出长度为j和k的边，这里是三维的，可以简化成二维，不需要记录i，每次长度从大往小枚举。 最后枚举所有用1-n块木板能组成的三边(i,j,sum-i-j)，先判断是否能组成三角形，然后计算面积更新答案。 一开始的 错误 int a=5; double b=a/2; b的值为2 double b=a/2.0; 或者 double b=double(a)/2; b的值为2.5 说这个是因为计算面积时，海伦公式里有一个p=(a+b+c)/2，可能是个小数。 本题的方法总结 动规不记录最优解，而是记录一个状态是否可行，可行的状态会有多个，最后更新最优解。 Code1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;int n,a[50],len;int dp[1610][1610];bool check(int x,int y,int z)&#123; if(x+y&gt;z&amp;&amp;x+z&gt;y&amp;&amp;y+z&gt;x) return true; else return false;&#125;double helen(double x,double y,double z)&#123; double p=double(len)/2; return sqrt(p*(p-x)*(p-y)*(p-z));&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],len+=a[i]; dp[0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=len;j&gt;=0;j--)//注意枚举顺序，否则状态重复更新 for(int k=len;k&gt;=0;k--) if((j&gt;=a[i]&amp;&amp;dp[j-a[i]][k])||(k&gt;=a[i]&amp;&amp;dp[j][k-a[i]])) dp[j][k]=1; double ans=-1; for(int i=0;i&lt;=len;i++) for(int j=0;j&lt;=len;j++) if(dp[i][j]&amp;&amp;len-i-j&gt;0&amp;&amp;check(i,j,len-i-j)) ans=max(ans,helen(i,j,len-i-j)*100); if(ans&gt;0) cout&lt;&lt;int(ans)&lt;&lt;endl; else cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0;&#125;","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"},{"name":"数学","slug":"数学","permalink":"http://copenlife.top/tags/数学/"}]},{"title":"尼克的任务(待批阅)","date":"2018-08-21T09:22:00.000Z","path":"2018/08/21/Nic-tasks/","text":"Problem 问题描述 尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完戍，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 输入格式 输入数据第一行含两个用空格隔开的整数N和K(1≤N≤10000，1≤K≤10000)，N表示尼克的工作时间，单位为分钟，K表示任务总数。 接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。 输出格式 仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 Analysis 我觉得这题我的思路还挺清晰的。 首先像这种很明显是线性动规，所有的工作看成数轴上的一段区间。 一开始我的想法是定义dp[i]表示1-i所能获得的最大空闲时间，然而这样做并不能满足无后效性，因为选择一样工作会导致之后的一些时间不能做其他工作，在之后的处理中，之前的处理会对之后有影响。 想起来以前做过一道题和这题很像，都是之前会对之后有影响。当时是从后往前进行动规的，因为只考虑当前点之后的情况，对于下一次操作没有任何影响。 于是可以换个思路，dp[i]表示i-n所能获得最大空闲时间。 dp[i]=dp[i+1]+1 (没有任务从i开始) dp[i]=max(dp[i+time[j]]) (选择第j个任务，就相当于是占用了time[j]个时间) 这里有一个注意点就是题目中说 “如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。” 要把时间看成一个区间，1开始持续2分钟意思是占用了1和2两个时间，一开始我以为是1开始，2结束，然后2还可以继续使用，方程写成了dp[i]=max(dp[i+time[j]-1]); 本题的方法总结: 当之前的情况对之后一段连续的区间有影响时，可以考虑从后往前进行状态转移。 Code O(n*m) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,dp[10010];vector &lt;int&gt; task[10010];void work()&#123; for(int i=n;i&gt;=1;i--)&#123; if(!task[i].size()) dp[i]=dp[i+1]+1; else for(int j=0;j&lt;task[i].size();j++) dp[i]=max(dp[i],dp[i+task[i][j]]); &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=k;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; task[x].push_back(y); &#125; work(); cout&lt;&lt;dp[1]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"}]},{"title":"多米诺骨牌(待批阅)","date":"2018-08-21T08:44:00.000Z","path":"2018/08/21/Domino/","text":"问题描述 多米诺骨牌有上下2个方块组成，每个方块中有1~6个点。现有排成行的n个多米诺骨牌如图所示。 编程用最少的旋转次数使多米诺骨牌上下2行点数之差达到最小。 对于上图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。 Analysis 每一块骨牌都可以选择翻或者不翻，像极了01背包。 不过这题状态的定义我想了好一会。开始我是用dp[i][j]表示前i张骨牌，翻j次所能取得的差值，但是这一题是让记录绝对值，这就让我不能单纯的考虑dp取更小还是更大。 然后就换了一个思路，答案要输出最小旋转次数，那我就可以考虑i张骨牌差值为j所需要的最小旋转次数。一开始不知道j的范围应该是多少，后来分析了一下，最多1000张牌，每张牌数字为1-6，差值一定在-5000~5000之间，这样算法复杂度1000*10000，可以过的。 状态转移方程如下： dp[i][j]=min(dp[i-1][j-dis],dp[i-1][j+dis]+1) (dis是x-y) dp[0][0]=0 但是这里j可能是负数，访问可能越界，所以要想一个方法让它不越界，处理这种问题一般都是把所有数字统一加上一个数，把负的调为正的。这里可以加上5005，不是5000，因为j要减去dis，dis最大为5。 最终方程如下: dp[i][j+N]=min(dp[i-1][j-dis+N],dp[i-1][j+dis+N]+1) (dis是x-y) dp[0][0+N]=0 N取5005 Code O(n*10000)1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define N 5010using namespace std;int n,x[1010],y[1010],dp[1010][10050];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; memset(dp,inf,sizeof(dp)); dp[0][N]=0;//初始化 for(int i=1;i&lt;=n;i++) for(int j=-5000;j&lt;=5000;j++) dp[i][j+N]=min(dp[i-1][j-(x[i]-y[i])+N],dp[i-1][j+(x[i]-y[i])+N]+1); int sum=inf,cnt=0; for(int j=0;j&lt;=5000;j++)//枚举绝对值，保证第一组解一定差值最小 if(dp[n][j+N]!=inf||dp[n][(-j)+N]!=inf)&#123; if(dp[n][j+N]&gt;dp[n][(-j)+N]) cout&lt;&lt;dp[n][(-j)+N]&lt;&lt;endl; else cout&lt;&lt;dp[n][j+N]&lt;&lt;endl; return 0; &#125;&#125;","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"}]},{"title":"邮局(待批阅)","date":"2018-08-21T08:22:00.000Z","path":"2018/08/21/postoffice/","text":"Problem 问题描述 一些村庄建在一条笔直的高速公路边上。我们用一条坐标轴来描述这条高速公路，每一个村庄的坐标都是整数，没有两个村庄坐标相同。两个村庄间的距离，定义为它们的坐标值差的绝对值。我们需要在一些村庄建立邮局――当然，并不是每一个村庄都必须建立邮局 邮局必须被建在村庄里，因此它的坐标和它所在村庄坐标相同。每个村庄便用离它最近的那个邮局，建立这些邮局的原则是：所有村庄到各自所使用的邮局的距离总和最小。 你的任务是编写一个程序，在给写了每个村庄的坐标和将要建立的邮局数之后，按照上述原则，合理地选择这些邮局的位置。 输入格式 输入的第一行包含两个整数；第一个整数是村庄的数目V（1&lt;=V&lt;=300）；第二个整数是将建立的邮局数P(1&lt;=P&lt;=30且P第二行递增顺序列出了V个整数。这V个整数分别表示了各村庄的位置坐标。对于每一个位置坐标X，1&lt;=X&lt;=10000. 输出格式 输出只有一个整数S，表示你所求出的所有村庄到距离它最近的邮局的距离总和。 样例输入 10 5 1 2 3 6 7 9 11 22 44 50 样例输出 9 Analysis(详细) 这一题就是对我一个动规基础极差的人的致命一击。我可能没救了。 首先一开始读完题我就蒙了，因为题目中说每一个邮局送信给离他最近的一个村庄，但是我们在动规的过程中一般是不记录当前的选择，只记录答案的。。。所以我怎么知道当前的邮局和之前的邮局哪个离得近。。。想到这儿基本上快放弃了。所以只能重新静下心来努力分析动规。 我抱着试一试的心态命令dp[i][j]表示到第i个村庄为止，建了j个邮局所需要的最短送信距离。没想到居然对了 但是我还在纠结走到最近邮局这个信息。。。然后我就去看了一下cty的解题报告，发现他一开始和我有一样的想法，他是这么解释的 其实这并不影响动规，虽然题目中说必须走离自己最近的邮局，假设如果不走最近的邮局，那么这样的答案肯定不是最优的，在动规枚举的时候总有一个可以枚举到比它更优的，那么它也会被更新掉。所以这个不需考虑前面的情况，只用考虑这个邮局负责哪一段。 我觉得他说的很有道理，但是还是不怎么太理解，就在纸上手算了一组数据 A={1,5,9,15,17}; 现在要求dp[5][2]; 假设两个邮局建在5和15位置上，明显9应该走到5，更新过程中我们计算了dp[2][1]+邮局建在15(送信给9,17)和dp[3][1]和邮局建在15(送信给17)，这样的话自然如果9-5 &lt; 15-9,后一种状态会更新掉前一种，所以无需考虑。 后来又去看了srz的解题报告，不愧是srz理解真透彻，一个邮局一定是连续送[k,i]之间所有的村庄，不可能说中间某一个不用送，那样不符合题意。所以每次的枚举总会是一段区间内的邮局送一段区间（其实我的模拟也是能看出来不过不清晰）。 然后我就用分析递归的思路分析，当前状态肯定是由之前的状态转移来的，但是如果我考虑之前建a个邮局，之后建b个邮局其实没必要，只需要考虑之前建j-1个，现在建一个，因为建j-1就是由建a扩展来的，这是一个逐渐推导的过程： dp[i][j]=min(dp[i]][j],dp[k][j-1]+dis[k+1][i]) 就是说可以由前面一个点扩展来，相当于在之后的一段距离里面算建一个邮局所需要的长度。 这里dis数组处理还算简单吧，数学老师上课刚讲过，奇数个点取中间，偶数个点取中间两个点任意一个。 其实我对于这个式子感到很迷茫，感觉以前做过相似的题目，所以就写了一下。 一开始初始值赋的不好，错了样例,因为我只把dp[1][1]赋值为0，把所有dp[i][1]都赋初值之后才对。 还有一个点就是动规方程里面一开始写成了dis[k][i]，后来发现必须写dis[k+1][i],因为k这个点被dp[k][j-1]包含在内了。 我又写了一篇很长但其实题目并不是太难的的解题报告，希望又能进步一点点。 本题的方法总结: 把一段区间看成一个点就好更新了。 另附：Code O(n\\^3+m*n^2)123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;int n,m,a[310],dis[310][310];int dp[310][40];void update_dis()&#123; for(int i=1;i&lt;=n;i++)//dis更新取中间点，其实很怕这里超时，因为三层循环，但是暂时没想到优化方法 for(int j=1;j&lt;=n;j++) if(i==j) dis[i][j]=0; else for(int k=i;k&lt;=j;k++) dis[i][j]+=abs(a[(i+j)&gt;&gt;1]-a[k]);&#125;void work()&#123; memset(dp,inf,sizeof(dp)); for(int i=1;i&lt;=n;i++) dp[i][1]=dis[1][i]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=min(i,m);j++) for(int k=i-1;k&gt;=j;k--) dp[i][j]=min(dp[i][j],dp[k][j-1]+dis[k+1][i]);//就是这里一开始写错了，转移错了。。。 return;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; update_dis(); work(); cout&lt;&lt;dp[n][m]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"}]},{"title":"书的复制(待批阅)","date":"2018-08-21T07:22:00.000Z","path":"2018/08/21/Copy-Books/","text":"Problem 问题描述 现在要把m本有顺序的书分给k给人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。 Analysis 因为是连续一段必须给一个人抄写，所以可以和邮局一样处理，用前缀和预处理出[i,j]所有数复制所需时间，得到方程如下 dp[i][j]=min(dp[i][j],max(dp[t][j-1],sum[i]-sum[t]) 意思就是i本书给j个人抄，可以假设前t本书给j-1个人抄，t+1到i本书给第j个人抄，取最大值最小。 这题的输出是个问题，其实只要从大往小，每次让后面的人抄尽可能多的就行了。一开始我没有考虑人数为0的情况，90分。 Code O(n^2*k)123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,a[510],sum[510],dp[510][510],ans[510][3];int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i]; memset(dp,0x7f,sizeof(dp)); for(int i=0;i&lt;=k;i++) dp[0][i]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++) if(i&lt;j) dp[i][j]=0; else for(int t=i-1;t&gt;=j-1;t--) dp[i][j]=min(dp[i][j],max(dp[t][j-1],sum[i]-sum[t])); int id=n,cnt=0; for(int i=n;i&gt;=1;i--) if(sum[id]-sum[i-1]&gt;dp[n][k])&#123; ans[++cnt][1]=i+1; ans[cnt][2]=id; id=i; &#125; if(k&gt;=1) ans[++cnt][1]=1,ans[cnt][2]=id;//这样写就是为了保证人数不为0. for(int i=cnt;i&gt;=1;i--) cout&lt;&lt;ans[i][1]&lt;&lt;\" \"&lt;&lt;ans[i][2]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"},{"name":"前缀和优化","slug":"前缀和优化","permalink":"http://copenlife.top/tags/前缀和优化/"}]},{"title":"字串距离(待批阅)","date":"2018-08-20T09:41:00.000Z","path":"2018/08/20/distance/","text":"Problem 问题描述 设有字符串X，我们称在X的头尾及中间插入任意多个空格后构成的新字符串为X的扩展串，如字符串X为”abcbcd”，则字符串“abcb□cd”，“□a□bcbcd□”和“abcb□cd□”都是X的扩展串，这里“□”代表空格字符。 如果A1是字符串A的扩展串，B1是字符串B的扩展串，A1与B1具有相同的长度，那么我扪定义字符串A1与B1的距离为相应位置上的字符的距离总和，而两个非空格字符的距离定义为它们的ASCII码的差的绝对值，而空格字符与其他任意字符之间的距离为已知的定值K，空格字符与空格字符的距离为0。在字符串A、B的所有扩展串中，必定存在两个等长的扩展串A1、B1，使得A1与B1之间的距离达到最小，我们将这一距离定义为字符串A、B的距离。 请你写一个程序，求出字符串A、B的距离 输入格式 输入第一行为字符串A，第二行为字符串B。A、B均由小写字母组成且长度均不超过2000。第三行为一个整数K（1≤K≤100），表示空格与其他字符的距离。 输出格式 仅一行包含一个整数，表示所求得字符串A、B的距离。 样例输入 cmc snmn 2 样例输出 10 Analysis 又是一道写出方程式却因为没有理解透彻而思考很久的题目。 两个字符串在一起容易想到线性动规，定义dp[i][j]表示s1的前i个和s2的前j个所求字符串距离。 dp[i][j]有两种情况： 将i,j对应，把i-1和j-1计算完毕，加上abs(s1[i]-s2[j])； 将i和空格对应，把i-1和j计算完毕，加上k； 将j和空格对应，把i和j-1计算完毕，加上k； 在这里一开始我有一个很大的疑问，就是我担心最后填出来的字符串，s1的长度可能和s2不等，需要多(少)空格，那我可能要在中途记录s1，s2选择加空格的次数，后来发现完全没必要，因为我没一次在处理时当前都是一一对应的，所以对于之后的状态而言，一定是由一个对应好的状态转移来，还是一一对应的。 以上，这一题做的还算顺畅，感谢srz的点拨。 Code O(l^2) 这里的边界值处理比较特殊，因为要考虑空格； 我的转移方程里i和j是之前的字符数，不是位置，所以从1开始枚举，不然的话数组会越界(-1)，而且便捷不好处理。 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int l1,l2,k,dp[2010][2010];string s1,s2;void work()&#123; for(int i=1;i&lt;=max(l1,l2);i++) dp[i][0]=dp[0][i]=i*k;//计算空格数 for(int i=1;i&lt;=l1;i++) for(int j=1;j&lt;=l2;j++) dp[i][j]=min(dp[i-1][j-1]+abs(s1[i]-s2[j]),min(dp[i-1][j]+k,dp[i][j-1]+k));&#125;int main()&#123; cin&gt;&gt;s1&gt;&gt;s2; cin&gt;&gt;k; l1=s1.size(),l2=s2.size(); work(); cout&lt;&lt;dp[l1][l2]&lt;&lt;endl; return 0;&#125; Conclusion 在分析状态转移方程时，要考虑当前转移方式下对于全局的影响，譬如这题转移后长度相同，可以采取srz’s blog 中分析最优子结构和无后效性。 之前我一直对于无后效性理解不太好，可以参照邮局那一题，采用动规时就要考虑无后效性，一开始正是因为不确定这一点才导致我无法写出方程。","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"}]},{"title":"花店橱窗布置(待批阅)","date":"2018-08-19T08:25:00.000Z","path":"2018/08/19/Flowershop/","text":"问题描述 假设你想以最美观的方式布置花店的橱窗。现在你有F束不同品种的花束，同时你也有至少同样数量的花瓶被按顺序摆成一行。这些花瓶的位置固定于架子上，并从1至V顺序编号，V是花瓶的数目，从左至右排列，则最左边的是花瓶1，最右边的是花瓶V。花束可以移动，并且每束花用1至F间的整数唯一标识。标识花束的整数决定了花束在花瓶中的顺序，如果I＜J，则令花束I必须放在花束J左边的花瓶中。 例如，假设一束杜鹃花的标识数为1，一束秋海棠的标识数为2，一束康乃馨的标识数为3，所有的花束在放入花瓶时必须保持其标识数的顺序，即：杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目。则多余的花瓶必须空置，且每个花瓶中只能放一束花。 每一个花瓶都具有各自的特点。因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数）来表示，空置花瓶的美学值为零。 在上述例子中，花瓶与花束的不同搭配所具有的美学值，如下表所示。 例如，根据上表，杜鹃花放在花瓶2中，会显得非常好看；但若放在花瓶4中则显得十分难看。 为取得最佳美学效果，你必须在保持花束顺序的前提下，使花束的摆放取得最大的美学值。 假设条件 1≤F≤100，其中F为花束的数量，花束编号从1至F。 F≤V≤100，其中V是花瓶的数量。 -50≤Aij≤50，其中Aij是花束i在花瓶j中的美学值。 输入格式 第一行包含两个数：F，V。 随后的F行中，每行包含V个整数，Aij 即为输入文件中第（i+1 ）行中的第j个数 输出格式 一行是程序所产生摆放方式的美学值。 Analysis (详细) 因为我对于动规的理解一直不是那么明了，所以做这道题还是用了我一些时间而且错了好多次。。。不过最后写完发现这明明就是个背包。 我的思路历程(写的无比详细)： 万幸的是，一开始动规方向是对的：令dp[i][j]表示前i个花束放在前j个花瓶中。我现在想想这句话说的就是背包问题，但是当时可能是被花束必须有序放置弄混淆了。。 然后我就开始思考了，dp[i][j]一定是由dp[i-1][k]扩展来的，而且k的范围是[i-1,j-1],所以可以三层循环，但是每次加上的美学值应该是[k+1,j]美学值最大的那个，但是这不好记下来，难道我要四层循环？？？100^4,过不了的。。。 后来的发现其实是一个偶然 也可能是必然，我是在处理边界时发现了状态，在填写dp[1][k]时，我每次都是 dp[1][k]=max(dp[1][k-1],a[1][k]) 结果发现其实每一个都可以这样转移 dp[i][j]=max(dp[i][j-1],dp[i-1][j-1]+a[i][j]) 其实看到这就明白，这不就是i个物品放入j个容器中，可以选择放或不放，放就是dp[i-1][j-1]+a[i][j],不放就是dp[i][j-1]。 然后我就非常兴奋的把这个程序交了上去，50分，想了很久没想出来原因，后来去洛古上找了一组数据，发现我的处理在一个细节上出了问题，那就是1234567891011一开始的写法for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=m;j++) dp[i][j]=max(dp[i][j-1],dp[i-1][j-1]+a[i][j]);修改之后的 for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=m;j++) if(j-1&gt;=i)dp[i][j]=max(dp[i][j-1],dp[i-1][j-1]+a[i][j]); else dp[i][j]=dp[i-1][j-1]+a[i][j]; 没有判断j-1&gt;=i，原因在哪？ 题目中是有负数的，如果dp[i][j]应该是一个负数，但是却按照之前的写法，由于dp[i][j-1]一开始没有被更新过，所以dp[i][j-1]=0,那么取max，dp[i][j]的值自然就被更新成0了。 以上就是这一题全部的解答过程，其实这题真的不难，我看别人的报告写的都很简略，可能是只有我不会。。。所以我写的非常详细。 本题的方法总结: 一旦遇到多个物品，多个选择放置这样类似的题目时，一定要想到背包问题的原型。 Code O(n*m)1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[110][110],dp[110][110];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) cin&gt;&gt;a[i][j]; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=m;j++)&#123; if(j-1&gt;=i)dp[i][j]=max(dp[i][j-1],dp[i-1][j-1]+a[i][j]); else dp[i][j]=dp[i-1][j-1]+a[i][j]; &#125; cout&lt;&lt;dp[n][m]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"}]},{"title":"回文词(待批阅)","date":"2018-08-19T07:23:00.000Z","path":"2018/08/19/Huiwenword/","text":"问题描述 回文词是一种对称的字符串－－也就是说，一个回文词，从左到右读和从右到左读得到的结果是一样的。任意给定一个字符串，通过若干字符，都可以变成一个回文词。你的任务是写一个程序，求出将给定的字符串变成回文词所需插入的最少字符数。 比如字符串“Ab3bd”，在插入两个字符后可以变成一个回文词（“dAb3Ad”，“Adb3bdA”)。然而，插入两个以下的字符无法使它变成一个回文词。 Analysis 令dp[i][j]表示[i,j]是回文需要插入的字符数。那么i和j存在两种情况： s[i]=s[j]，也就是s[i]可以和s[j]构成一组，那么只需要求出[i+1，j-1]就可以了。 s[i]!=s[j],那么就相当于(i,j-1)已经是回文的情况下在i之前添上一个s[j]，或者(i+1,j)已经是回文，在j之后添一个s[i]；这样都可以计算出(i,j)，只需要取一个最小值就可以了。 所以，状态转移方程如下： dp[i][j]=dp[i+1][j-1] (s[i]=s[j]) dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1 (s[i]!=s[j]) 这样做可行是因为每一个长度为l的区间，都是可以在小于l的区间全部计算完成之后，由其扩展而来。而且之前的选择对于之后的选择无影响。 Code 我写了两种枚举方法，我觉得枚举区间长度和其中一个端点，比枚举区间的两个端点要更清晰，因为枚举两个端点还要考虑之前的状态一定要全部计算完毕，所以枚举的顺序就要多考虑一点，但是枚举区间长度所牵涉到的状态全部是会被计算完毕的。 Code 1 枚举端点 O(len^2/2)123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int dp[5010][5010];int main()&#123;= string st; int n; cin&gt;&gt;n&gt;&gt;st; int len=st.size(); for(int i=len-1;i&gt;=0;i--)//i从大往小，因为可以发现有关i的状态会牵涉到i+1 for(int j=i+1;j&lt;len;j++) if(st[i]==st[j]) dp[i][j]=dp[i+1][j-1]; else dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1; cout&lt;&lt;dp[0][len-1]&lt;&lt;endl; return 0;&#125; Code 2 枚举长度 O(len^2/2)123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int dp[5010][5010];int main()&#123; int n; string st; cin&gt;&gt;n&gt;&gt;st; for(int k=1;k&lt;=n;k++) for(int i=0;i+k&lt;n;i++)&#123; if(st[i]==st[i+k]) dp[i][i+k]=dp[i+1][i+k-1]; else dp[i][i+k]=min(dp[i+1][i+k],dp[i][i+k-1])+1; &#125; cout&lt;&lt;dp[0][n-1]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"}]},{"title":"最长公共子序列(待批阅)","date":"2018-08-19T02:45:00.000Z","path":"2018/08/19/LCS/","text":"问题描述 序列Z=是序列X=的子序列，相应的递增下标序列为&lt;2，3，5，7&gt;。 一般地，给定一个序列X=，则另一个序列Z=是X的子序列，是指存在一个严格递增的下标序列〈i1,i2,…,ik〉使得对于所有j=1,2,…,k使Z中第j个元素zj与X中第ij个元素相同。 给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。 你的任务是：给定2个序列X、Y，求X和Y的最长公共子序列Z的长度。 输入格式 输入共有两行，每行为一个由大写字母构成的长度不超过200的字符串，表示序列X和Y。(ABCBDAB BDCABA) 输出格式 输出只有一个整数表示最长公共子序列的长度。(4) Analysis 一开始题目理解错了，以为子序列是连续的，其实那是子串，子序列只需要下标递增即可。 令dp[i][j]表示s1的前i个字符,s2的前j个字符中的最长公共子序列。 dp[i][j]=dp[i-1][j-1]+1 (s1[i]=s2[j]) dp[i][j]=max(dp[i-1][j],dp[i][j-1]) (s1[i]!=s2[j]) 证明过程我自己也很模糊，所以去网上看了一下，原来这个是一种名叫LCS的算法，网上有很多证明，我大概写了一下自己的理解： 设s={z1,z2..zk}是s1={x0,x1…xi},s2={y0,y1…yj}的最长公共子序列，且xi=yj， 如果把xi作为zk,yj也是zk,那么dp(i,j)=dp(i-1,j-1)+1。 如果把xi作为zk，y不作为zk，dp(i,j)=dp(i,j-1),如果在(i-1,j-1)的最长公共子序列之后还能找到一个y和xi对应，那么dp(i,j-1)和dp(i-1,j-1)+1值相等，否则dp(i,j-1)&lt;dp(i-1,j-1)+1。 如果把yi作为zk，证明方法同上。 所以当s1[i]=s2[j]时，dp[i][j]最大为dp[i-1][j-1]+1。 设s={z1,z2..zk}是s1={x0,x1…xi},s2={y0,y1…yj}的最长公共子序列，且xi!=yj，通过上面的推断，子序列一定在(i,j-1)和(i-1,j)之中，所以得到第二个式子。 一开始的 错误: 如果i=0或者j=0的话,dp[i][j]最大为1，要特殊处理一下Code O(n^2)123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int dp[1010][1010];int main()&#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; int l1=s1.size(),l2=s2.size(); for(int i=0;i&lt;l1;i++) for(int j=0;j&lt;l2;j++)&#123; if(i==0||j==0)&#123; if(s1[i]==s2[j]) dp[i][j]=1; else dp[i][j]=dp[max(0,i-1)][max(0,j-1)]; &#125; else if(s1[i]==s2[j]) dp[i][j]=dp[i-1][j-1]+1; else if(s1[i]!=s2[j]) dp[i][j]=max(dp[i][j-1],dp[i-1][j]); &#125; cout&lt;&lt;dp[l1-1][l2-1]&lt;&lt;endl; return 0;&#125; Conclusion 在之前分析动规方程时经常迷迷糊糊混了过去，以后要弄清楚了。","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"}]},{"title":"数字三角形(待批阅)","date":"2018-08-19T02:43:00.000Z","path":"2018/08/19/NumTriangle/","text":"问题描述 给定一个由n 行数字组成的数字三角形如下图所示。试设计一个算法，计算出从三角形的顶至底的一条路径，使该路径经过的数字总和最大 。 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 编程任务 ：对于给定的由n 行数字组成的数字三角形，编程计算从三角形的顶至底的路径经过的数字和的最大值 。 **每一步可沿直线向下或右斜线向下走。 **1&lt;三角形行数&lt;100； **三角形中的数字为整数0，1，…，99； Analysis 这是学习动规时候做的第一道题目，每一个点都可以正下和右下扩展，也就是每个点都是有正上和左上扩展来的，所以得到 dp[i][j]=a[i][j] (i=1&amp;&amp;j=1) dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+a[i][j] 为了使得最后出解更方便，可以从下向上进行状态转移，也就是 dp[i][j]=a[i][j] (i=n) dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j] (i&lt;&gt;n) Code O(n^2/2)123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[1010][1010],dp[1010][1010];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; for(int i=1;i&lt;=n;i++) dp[n][i]=a[n][i]; for(int i=n-1;i&gt;=1;i--) for(int j=1;j&lt;=i;j++) dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j]; cout&lt;&lt;dp[1][1]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"动态规划初步","slug":"动态规划初步","permalink":"http://copenlife.top/categories/动态规划初步/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://copenlife.top/tags/动态规划/"}]},{"title":"借教室(已批阅)","date":"2018-08-17T15:21:45.000Z","path":"2018/08/17/借教室/","text":"Problem from NOIP2012T 问题描述 在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为dj,sj,tj，表示某租借者需要从第sj天到第tj天租借教室（包括第sj天和第tj天），每天需要租借dj个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教室数量不足dj个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 输入格式 第一行包含两个正整数n,m，表示天数和订单的数量。 第二行包含n个正整数，其中第i个数为ri，表示第i天可用于租借的教室数量。 接下来有m行，每行包含三个正整数dj,sj,tj，表示租借的数量，租借开始、结束分别在第几天。 每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。 样例输入 4 3 2 5 4 3 2 1 3 3 2 4 4 2 4 输出格式 如果所有订单均可满足，则输出只有一行，包含一个整数0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。 样例输出 -1 2 Analysis 上课的线段树例题，不过线段树模板忘得差不多了，还是去看看之前写的才想起来。 结构体用minv记录[l,r]之间的最小值，用一个lazy标记或用标记永久化(效率更高)。 首先建树，build_tree(1,1,n) 然后每次读入后，把相应的区间修改(-1)，最后返回根节点的minv，如果minv &lt; 0,就说明至少有一天的状态不合法了，就直接输出-1。 Code (lazy 标记版) 由于每次lazy标记都要向下传递，是一个常数的运算，所以在大数据时会被卡，不过日常解决线段树还是不二之选 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define MAXN 1000010using namespace std;struct tnode&#123; int minv,lft,rgt,lazy;&#125;a[MAXN*4+10];int n,m,k,num[MAXN];int read()&#123; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); int x=0; while(ch&gt;='0'&amp;&amp;ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar(); return x;&#125;void build_tree(int r,int x,int y)&#123;//建树 a[r].lft=x,a[r].rgt=y; if(x==y)&#123; a[r].minv=num[x]; return; &#125; else&#123; int mid=(x+y)&gt;&gt;1; build_tree(r*2,x,mid),build_tree(r*2+1,mid+1,y); a[r].minv=min(a[r*2].minv,a[r*2+1].minv); return; &#125;&#125;void push(int r)&#123; a[r].minv-=a[r].lazy; a[r*2].lazy+=a[r].lazy,a[r*2+1].lazy+=a[r].lazy; a[r].lazy=0;&#125;void update(int r,int x,int y)&#123; push(r);//一开始一定要先push，把上一次的标记更新一下，不然之后可能会被清掉 int lft=a[r].lft,rgt=a[r].rgt; if(lft&gt;=x&amp;&amp;rgt&lt;=y)&#123; a[r].lazy+=k; push(r); return;//记得return，不然lazy标记在以后会被重复更新 &#125; if(lft&gt;y||rgt&lt;x) return; update(r*2,x,y); update(r*2+1,x,y); a[r].minv=min(a[r*2].minv,a[r*2+1].minv);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) num[i]=read(); build_tree(1,1,n); for(int i=1;i&lt;=m;i++)&#123; int x,y ; k=read(),x=read(),y=read(); update(1,x,y); if(a[1].minv&lt;0)&#123; printf(\"-1\\n\"); printf(\"%d\\n\",i); return 0; &#125; &#125; printf(\"0\\n\"); return 0;&#125; 接着就是srz给我介绍的标记永久化，定理比较复杂，我真的不知道如何阐述，复制一下： 原理就是： 在路过该节点的时候把修改对答案的影响加上，来省去标记下放的过程 自我理解（完全凭感觉）： 想象一下，当前的minv是子树更新来的，也就是当时没有lazy标记但是可能修改到当前的minv，而当前的lazy标记记录的是没有继续搜索的所有更新值，只要把当前的minv-lazy就可以得到目前的状态值。 举个例子： 修改[3,5],现在状态是[4,5],就不用再搜索，直接lazy++； 第二次修改[3,4],现在状态依旧是[4,5]，就需要继续搜索然后更新，而最终[4,5]这个状态的值应该是第二次修改过的-第一次的lazy标记。 我觉得应该就是这样的吧。 Code (标记永久化) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define MAXN 1000010using namespace std;struct tnode&#123; int minv,lft,rgt,lazy;&#125;a[MAXN*4+10];int n,m,k,num[MAXN];int read()&#123; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); int x=0; while(ch&gt;='0'&amp;&amp;ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar(); return x;&#125;void build_tree(int r,int x,int y)&#123;//建树 a[r].lft=x,a[r].rgt=y; if(x==y)&#123;//叶子节点 a[r].minv=num[x]; return; &#125; else&#123; int mid=(x+y)&gt;&gt;1; build_tree(r&lt;&lt;1,x,mid),build_tree(r&lt;&lt;1|1,mid+1,y); a[r].minv=min(a[r&lt;&lt;1].minv,a[r&lt;&lt;1|1].minv); return; &#125;&#125;void update(int r)&#123; a[r].minv=min(a[r&lt;&lt;1].minv-a[r&lt;&lt;1].lazy,a[r&lt;&lt;1|1].minv-a[r&lt;&lt;1|1].lazy);&#125;void del(int r,int x,int y)&#123; int lft=a[r].lft,rgt=a[r].rgt; if(lft&gt;=x&amp;&amp;rgt&lt;=y)&#123;//当前区间属于[x,y] a[r].lazy+=k; return; &#125; if(lft&gt;y||rgt&lt;x) return; del(r&lt;&lt;1,x,y); del(r&lt;&lt;1|1,x,y); update(r);//每次都要更新(下面全部更新完毕)&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) num[i]=read(); build_tree(1,1,n); for(int i=1;i&lt;=m;i++)&#123; int x,y ; k=read(),x=read(),y=read(); del(1,x,y); if(a[1].minv-a[1].lazy&lt;0)&#123; printf(\"-1\\n\"); printf(\"%d\\n\",i); return 0; &#125; &#125; printf(\"0\\n\"); return 0;&#125; 这一题的永久化还比较简单，因为最后只需要返回根的值，如果返回任意区间的值，需要写函数。把我从网上找的线段树标记永久化标程写一下。 123456int query(int i,int l,int r)&#123;//返回i区间和[l,r]的交集中的最小值 if(l(i)&gt;r||r(i)&lt;l) return 0x3f3f3f3f;//没有交集，返回inf if(l(i)&gt;=l&amp;&amp;r(i)&lt;=r) return ata(i)-minus(i);//[l,r]包含i区间，直接返回i区间的最小值 return min(query(i&lt;&lt;1,l,r),query(i&lt;&lt;1|1,l,r))-minus(i);//否则就往下搜索 &#125; 这题既然放在这里，还是要写一下二分的，二分答案，也就是第几天不能满足要求。只需要把之前的所有教室使用个数算出来，然后看有没有大于教室总数的，如果有返回false。 如果最后返回false，说明r=mid，反之l=mid; 因为每次枚举教室的使用不可能把[l,r]全部枚举，然后加1，所以我们可以用前缀和优化： 举个例子[l,r]=[2,5]; 开始时数组 s[10]={0}; s[2]++,s[6]–; 数组变为 s[10]={0,0,1,0,0,0,-1,0,0,0,0}; 此数组前缀和为 pre[10]={0,0,1,1,1,1,0,0,0,0}; 这样就巧妙地用pre数组记录下了每天的使用情况。 Code O(logm·(m+n))12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define MAXN 1000010#define inf 0x3f3f3f3fusing namespace std;int n,m,k,num[MAXN],pre[MAXN],t[MAXN],x[MAXN],y[MAXN];int read()&#123; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); int x=0; while(ch&gt;='0'&amp;&amp;ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar(); return x;&#125;bool check(int k)&#123; memset(pre,0,sizeof(pre)); for(int i=1;i&lt;=k;i++) pre[x[i]]+=t[i],pre[y[i]+1]-=t[i];//其实我之前的s[],pre[]可以合并成一个。 for(int i=1;i&lt;=n;i++) pre[i]+=pre[i-1]; for(int i=1;i&lt;=n;i++) if(pre[i]&gt;num[i]) return false; return true;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) num[i]=read(); for(int i=1;i&lt;=m;i++) t[i]=read(),x[i]=read(),y[i]=read(); int l=0,r=m,ans=inf; while(l&lt;=r)&#123;//二分 int mid=l+((r-l)&gt;&gt;1); if(check(mid)) l=mid+1; else ans=min(ans,mid),r=mid-1; &#125; if(ans==inf) printf(\"0\\n\"); else printf(\"-1\\n%d\\n\",ans); return 0;&#125; Conclusion： 对于线段树lazy标记的使用不是特别清楚，迷迷糊糊的只能画图验证自己的猜想，还是要多写写多想想。 课后修改为何满足二分性质： 如果存在解一定在1-m之间，比ans小的天数一定可以分配好教室，比ans大的天数一定无法分配教室。 1-m是离散点，每一个点都可以判断是否可行。 分析左右区间端点，l=0，所有小于l的都可行，r=m，如果有解，一定&lt;=r。但是这个地方老师说我这种写法不好，因为我做了很多无用的ans更新，这里可以这样修改一下（左闭右开）12345678int l=0,r=m+1;while(l&lt;r)&#123; int mid=l+((r-l)&gt;&gt;1); if(check(mid)) l=mid+1; else r=mid;&#125;if(r==m+1) cout&lt;&lt;\"0\"&lt;&lt;endl;//说明所有都可行，r没有更新过else cout&lt;&lt;\"-1\"&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;//因为不可行才会更新r，所以&gt;=r的点都是不可行的，r就是解","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"},{"name":"前缀和优化","slug":"前缀和优化","permalink":"http://copenlife.top/tags/前缀和优化/"},{"name":"线段树","slug":"线段树","permalink":"http://copenlife.top/tags/线段树/"},{"name":"线段树优化","slug":"线段树优化","permalink":"http://copenlife.top/tags/线段树优化/"}]},{"title":"聪明的质检员(已批阅)","date":"2018-08-17T15:21:32.000Z","path":"2018/08/17/聪明的质检员/","text":"Problem from NOIP2011T 问题描述 小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有n 个矿石，从1到n 逐一编号，每个矿石都有自己的重量wi 以及价值vi。检验矿产的流程是： 1、给定m 个区间[Li，Ri]； 2、选出一个参数W； 3、对于一个区间[Li，Ri]，计算矿石在这个区间上的检验值Yi ： 这批矿产的检验结果Y 为各个区间的检验值之和。即： 若这批矿产的检验结果与所给标准值S 相差太多，就需要再去检验另一批矿产。小T不想费时间去检验另一批矿产，所以他想通过调整参数W 的值，让检验结果尽可能的靠近标准值S，即使得S-Y 的绝对值最小。请你帮忙求出这个最小值。 输入格式 第一行包含三个整数 n，m，S，分别表示矿石的个数、区间的个数和标准值。 接下来的 n 行，每行2 个整数，中间用空格隔开，第i+1 行表示i 号矿石的重量wi 和价值vi 。 接下来的 m 行，表示区间，每行2 个整数，中间用空格隔开，第i+n+1 行表示区间[Li,Ri]的两个端点Li 和Ri。注意：不同区间可能重合或相互重叠。 输出格式 输出只有一行，包含一个整数，表示所求的最小值。 Analysis 题目意思就是，每次找一个参照值mid，m个区间每个区间内都记录w&gt;=mid的矿产的个数和价值和，然和相乘累加得到sum，求出|sum-S|的最小值。 在[0,max]区间内二分参照值，求出sum。 情况如下： sum&gt;S,要尽量把sum减小使得更接近S，需要把参照值变大。 sum&lt;S,要尽量把sum增加使得更接近S，需要把参照值减小。 sum=S，直接输出0 然后我就直接写一个裸的二分，没有优化： Code O(logmax·m·n) max是质量最大值，m是区间总数，n是矿产总数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 0x3f3f3f3f3fusing namespace std;struct node&#123; ll w,v;&#125;a[200010];bool cmp (node p,node q)&#123; return p.w&lt;q.w;&#125;ll n,m,s;ll x[200010],y[200010];int read()&#123; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); int x=0; while(ch&gt;='0'&amp;&amp;ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar(); return x;&#125;ll work(int k)&#123; ll sum=0; for(int i=1;i&lt;=m;i++)&#123; ll sum1=0,sum2=0; for(int j=x[i];j&lt;=y[i];j++) if(a[j].w&gt;=k) sum1++,sum2+=a[j].v; sum+=sum1*sum2; &#125; return sum;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; ll l=0,r=0; ll ans=inf; for(int i=1;i&lt;=n;i++) a[i].w=read(),a[i].v=read(),r=max(r,a[i].w); for(int i=1;i&lt;=m;i++) x[i]=read(),y[i]=read(); while(l&lt;=r)&#123; ll mid=(l+r)&gt;&gt;1; ll sum=work(mid); if(abs(sum-s)&lt;ans) id=mid,ans=abs(sum-s); if(sum&gt;s) l=mid+1; else r=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 题目中给出m，n的范围，m*n是肯定过不了的，所以在计算sum时需要优化。 我们发现每次都要在一个区间内求大于mid的个数和价值，这样就会重复计算，比如[1,4]和[2,6]有公共部分。 在求区间值，而且区间固定没有变化时，通常可以用前缀和，在这里只需要预先处理出[1,n]每个点的前缀和（包括个数和价值），然后枚举1-m，每次直接计算就行。 Code O(logmax·(m+n)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ll long long#define inf 9999999999999using namespace std;struct node&#123; ll w,v;&#125;a[200010],pre[200010];bool cmp (node p,node q)&#123; return p.w&lt;q.w;&#125;ll n,m,s;ll x[200010],y[200010];int read()&#123; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); int x=0; while(ch&gt;='0'&amp;&amp;ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar(); return x;&#125;ll work(int k)&#123; pre[0].w=pre[0].v=0; ll sum=0; for(int i=1;i&lt;=n;i++)//计算前缀和 if(a[i].w&gt;=k)//需要更新 pre[i].w=pre[i-1].w+1,pre[i].v=pre[i-1].v+a[i].v; else pre[i].w=pre[i-1].w,pre[i].v=pre[i-1].v; for(int i=1;i&lt;=m;i++) sum+=(pre[y[i]].v-pre[x[i]-1].v)*(pre[y[i]].w-pre[x[i]-1].w); return sum;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; ll l=0,r=0; ll ans=inf; for(int i=1;i&lt;=n;i++) a[i].w=read(),a[i].v=read(),r=max(r,a[i].w); for(int i=1;i&lt;=m;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; while(l&lt;=r)&#123; ll mid=(l+r)&gt;&gt;1; ll sum=work(mid); if(abs(sum-s)&lt;ans) ans=abs(sum-s); if(sum&gt;s) l=mid+1; else r=mid-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Conclusion 又一次感受到前缀和的魅力，至今为止我用过前缀和的地方： 简单的区间内计算，不仅仅是求和，还可以是各种各样的计算； 树状数组； 在一些累加计算的地方，比如求和，魔法阵。大部分是a1·a2+a1·a2+…+a1·an+a2·a3+…+an-1·an之类的，从前往后每次记录sum，直接乘就好了； 可能还有其他的一时想不起来了，以后慢慢写。 课后修改分析： sum-S的值，当选择的参照w越大时，sum越小，sum-S越小；当选泽的参照w越小时，sum越大，sum-S越大。这就相当于f(w)=sum-S，是一个单调递减的函数，我们要找的就是在0-max区间内f(w)最接近临界值所对应的整数w值。 我的区间定义是从[0,max]中所有w值都可以取到，因为如果w&gt;max说明sum=0，w&lt;0说明所有石头都可以取到。 一样的问题,ans无用更新太多，正确解法是是保证f(l)&gt;=0，f(r)&lt;0，最后把[l,r]区间长度缩为2，计算左右端点即可。123456789l=0,r=max+1;while(l+1&lt;r)&#123;//这里我开始想错了，应该是保证最后l+1=r。 ll mid=(l+r)&gt;&gt;1; ll sum=work(mid); if(sum-s&gt;=0) l=mid; else r=mid; &#125;int suml=work(l),sumr=work(r);cout&lt;&lt;min(suml-s,s-sumr)&lt;&lt;endl;","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"},{"name":"前缀和优化","slug":"前缀和优化","permalink":"http://copenlife.top/tags/前缀和优化/"}]},{"title":"麦森数(已批阅)","date":"2018-08-17T15:21:21.000Z","path":"2018/08/17/麦森数/","text":"Problem From：NOIP2003P 问题描述 形如2^P-1的素数称为麦森数，这时P一定也是个素数。但反过来不一定，即如果P是个素数，2^P-1不一定也是素数。到1998年底，人们已找到了37个麦森数。最大的一个是P=3021377，它有909526位。麦森数有许多重要应用，它与完全数密切相关。 任务：从文件中输入P（1000&lt;P&lt;3100000），计算2^P-1的位数和最后500位数字（用十进制高精度数表示） 输入格式 文件中只包含一个整数P（1000&lt;P&lt;3100000） 输出格式 第一行：十进制高精度数2^P-1的位数。 第二行：十进制高精度数2^P-1的最后500位数字。 不必验证2^P-1与P是否为素数。 Analysis 快速幂+大整数乘法。 按照快速幂的格式，写一个重载运算符。 写程序中出错基本上都是大整数乘法，错误点： 位数算错了 最后的进位处理错了 位数是一个很重要的点，因为只要输出后500位，所以运算只需要进行到第500位，但是算位数又必须全部计算，所以这里有个矛盾点，一开始我就直接全部计算，只有20分（TLE+RE）然后我就不知道怎么办了。 然后就开始在网上找计算位数的方法： 首先，2 ^ k与2 ^ k-1位数相同，因为2^k末尾不可能是0 其次，10^k有k+1位 所以只需要把2 ^ p改为10 ^ k就可以知道位数 也就是 10 ^ k =2 ^ p，10 ^ q=2，q=log10(2)，2 ^ p = (10 ^ log10(2)) ^ p=10 ^(log10(2)*p) 所以位数是log10(2)*p+1; 用c++自带函数log Code O(logP·len)P是次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;struct bigint&#123; int len,num[5100]; bigint operator = (bigint x)&#123; len=x.len; for(int i=0;i&lt;len;i++) num[i]=x.num[i]; return *this; &#125; bigint operator = (string st)&#123; len=st.size(); for(int i=0;i&lt;len;i++) num[i]=st[len-i-1]-'0'; return *this; &#125; bigint operator * (bigint x)&#123;//这个是大整数乘大整数，不是以前的乘常数 bigint ans; memset(ans.num,0,sizeof(ans.num)); ans.len=min(500,len+x.len); for(int i=0;i&lt;len;i++) for(int j=0;j&lt;x.len;j++) if(i+j&lt;ans.len) ans.num[i+j]+=num[i]*x.num[j]; int next=0; for(int i=0;i&lt;ans.len;i++)&#123;//大整数加法的算法 ans.num[i]+=next; next=ans.num[i]/10; ans.num[i]=ans.num[i]%10; &#125; while(next)//这里要记得把后面的数字加上 ans.len++,ans.num[ans.len-1]=next%10,next/=10; while(!ans.num[ans.len-1]&amp;&amp;ans.len&gt;0) ans.num[ans.len-1]=0,ans.len--;//去除前导0 return ans; &#125; bigint operator - (int x)&#123;//就是减1 num[0]--; return *this &#125;&#125;;bigint ans,k;int p;int main()&#123; int p; cin&gt;&gt;p; k=\"2\",ans=\"1\"; int s=p*log10(2)+1; cout&lt;&lt;s&lt;&lt;endl; while(p!=0)&#123;//快速幂 if(p&amp;1) ans=ans*k; k=k*k; p/=2; &#125; ans=ans-1; for(int i=500-1;i&gt;=0;i--) cout&lt;&lt;ans.num[i]; return 0;&#125;","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"},{"name":"高精度","slug":"高精度","permalink":"http://copenlife.top/tags/高精度/"}]},{"title":"关押罪犯(已批阅)","date":"2018-08-17T15:21:11.000Z","path":"2018/08/17/关押罪犯/","text":"Problem From：NOIP2010T 问题描述 S 城现有两座监狱，一共关押着N 名罪犯，编号分别为1~N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为c 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 在详细考察了N名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那么，应如何分配罪犯，才能使Z市长看到的那个冲突事件的影响力最小？这个最小值是多少？ 输入格式 输入文件的每行中两个数之间用一个空格隔开。 第一行为两个正整数N 和M，分别表示罪犯的数目以及存在仇恨的罪犯对数。 接下来的M 行每行为三个正整数aj，bj，cj，表示aj 号和bj 号罪犯之间存在仇恨，其怨气值为cj。数据保证1&lt;=aj&lt;bj&lt;N,0&lt;cj&lt;=1,000,000,000 且每对罪犯组合只出现一次。 输出格式 输出共1 行，为Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。 Analysis 第一直觉对手并查集，虽然他和二分关系不大，但是还是写了一下。 首先这里面有一个贪心的思想，因为我们要输出最大冲突，所以在安排罪犯时，应该按照冲突值从大到小安排，这样可以保证当前罪犯如果没有被安排到同一个监狱，就进行下一组，如果不得不安排在一个监狱（之前冲突值更大的安排完毕），就直接输出当前冲突值（以后都比这个值小）。 之后就每一次都找到x,y的祖先，分情况 fx=fy，直接输出 fx!=fy，将x与y的对手，y与x的对手合并，如果暂时x(y)没有对手，就把y(x)安排为它的对手。 我开两个数组记录对手和朋友。 一开始的错误点: 对手合并时没有考虑没有对手的情况，导致祖先变成0了。 Code O(m+n)12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int x,y,num;&#125;a[100010];bool cmp (node p,node q)&#123; return p.num&gt;q.num;&#125;int n,m;int fa[20010],enemy[20010];int find(int k)&#123; if(fa[k]==k) return k; else return fa[k]=find(fa[k]);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;a[i].x,&amp;a[i].y,&amp;a[i].num); sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++)&#123; int fx=find(a[i].x); int fy=find(a[i].y); if(fx==fy)&#123; cout&lt;&lt;a[i].num&lt;&lt;endl; return 0; &#125; if(!enemy[a[i].x]) enemy[a[i].x]=fy;//没有对手就直接修改，否则就要把对手合并 else fa[find(enemy[a[i].x])]=fy; if(!enemy[a[i].y]) enemy[a[i].y]=fx; else fa[find(enemy[a[i].y])]=fx; &#125; cout&lt;&lt;\"0\"&lt;&lt;endl; return 0;&#125; 以上是之前学习过的并查集算法。 然而这个题目的确可以二分答案，此中涉及到了二分图，定义什么的，我不清楚，在此陈述一下方法： 首先二分枚举最大的冲突值，那么冲突值大于mid的罪犯必须拆开，我们只需要判定是否有这样的罪犯会属于一个连通图。 下面说一下判定二分图（网上学来的染色法）： 首先枚举一个点，如果这个点没有染色，就开始宽搜（其实的确很像宽搜）。首先把这个点染色入队，然后枚举与他有边的点。我们只处理冲突值大于mid的，因为小于mid的没什么意义（无法确定染什么色）。如果当前点已经被染色并且颜色相同，说明已经出现冲突值大于mid的两个点在同一个无向图中，返回false。如果，没有被染色，就把他染成不同的颜色，然后就入队。 当所有点都被染色过之后没有false，就直接返回true。 一开始的错误点: 每次的队列忘记清空，因为我一开始认为只有q.empty(),才会停止宽搜，其实我可能是中图退出了，所以一定要记得清空队列。 又忘记了闭区间需要l&lt;=r。 数组开小了，这个错误我犯了好多次，并不是忘记+10，而是因为在无向图里面，我每条边用前向星时都入队了两次，所以数组要开两倍大，否则RE了。 Code O(n · logk) k是最大冲突值，这里的check函数算法复杂度我算的比较牵强123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;struct node&#123; int x,y,num;&#125;a[200010];bool cmp (node p,node q)&#123; return p.num&gt;q.num;&#125;int n,m,cnt=0;int u[200010],v[200010],w[200010],next[200010],head[200010];void add(int x,int y,int z)&#123; u[++cnt]=x; v[cnt]=y; w[cnt]=z; next[cnt]=head[x]; head[x]=cnt;&#125;queue &lt;int&gt; q;bool check(int k)&#123;//二分图 int col[100010]=&#123;0&#125;; while(!q.empty()) q.pop();//这里一开始写错了，忘记清空队列了 for(int i=1;i&lt;=n;i++)//开始时没想到枚举i，以为一次宽搜图就分好了。 if(!col[i])&#123; col[i]=1; q.push(i); while(!q.empty())&#123; int t=q.front(); q.pop(); for(int j=head[t];j;j=next[j]) if(w[j]&gt;k)&#123;//这里一开始把w[j]&lt;=k也想入队，但是后来想想，这样的话太随意了。。 if(!col[v[j]])&#123; q.push(v[j]); if(col[t]==1) col[v[j]]=2; else col[v[j]]=1; &#125; else if(col[v[j]]==col[t]) return false; &#125; &#125; &#125; return true;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int l=0,r=0; for(int i=1;i&lt;=m;i++)&#123; int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); r=max(r,z); &#125; int ans=inf; while(l&lt;=r)&#123; int mid=(r+l)&gt;&gt;1; if(check(mid)) ans=min(ans,mid),r=mid-1;//可行就说明可能会有更小的ans else l=mid+1; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125;","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://copenlife.top/tags/二分图/"},{"name":"并查集","slug":"并查集","permalink":"http://copenlife.top/tags/并查集/"}]},{"title":"跳石头(已批阅)","date":"2018-08-16T15:23:56.000Z","path":"2018/08/16/跳石头/","text":"Problem from NOIP2015T 问题描述 一年一度的“跳石头”比赛又要开始了！ 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有N块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走M块岩石（不能移走起点和终点的岩石）。 输入格式 输入文件第一行包含三个整数L，N，M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。 接下来N行，每行一个整数，第i行的整数Di（0 &lt; Di &lt; L）表示第i块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。 输出格式 输出文件只包含一个整数，即最短跳跃距离的最大值。 Analysis 通过这一题，理解了二分答案的概念，以前对于二分一直很模糊，不知道二分的主体是什么，这一题的分析就很重要。 首先我看到这一题的第一想法是算出每两块石头（包括起点和终点）之间的距离，从中选出距离最小的两块，搬走其中一块。然后我就开始想这个应该怎么二分，难道二分找出最短距离？很疑惑，而且后来发现这个搬走石头后的状态很难维护，而且二分是一般是离线的，明显，这个思路不可行。 后来我想了很久没有思路，然后从别人那里得知二分答案，也就是二分最短跳跃距离，就此方法，我展开了下面的分析。 如果我们当前最短跳k个距离，那么我们就要搬走所有小于k的石头，这个可以枚举得到（其实有贪心的思想，如果当前点跳不到，搬走当前石头一定是最好的选择），记录上一个没有被搬走的石头的坐标x，如果当前坐标y，y-x&gt;k就不更新x，否则更新为y。更新时把sum++。 这样，我们就可以得到k情况下需要移走的石头数。 下面就是二分。 sum &lt; m,可以移走更多的石头，则k可以取更大值 sum &gt; m,k需要取更小值 这样，我们就可以通过二分k的值，每次计算出sum与m进行比较，缩小区间。 Code O(m·logm)1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int L,m,n,a[50010];int work(int k)&#123; int ans=0,last=0;//一定要记录last，否则不知道上一块石头搬没搬走。 for(int i=1;i&lt;=m+1;i++)&#123; if(a[i]-last&lt;k) ans++; else last=a[i]; &#125; return ans;&#125;int main()&#123; cin&gt;&gt;L&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++) scanf(\"%d\",&amp;a[i]); a[m+1]=L;//需要枚举到终点 int l=0,r=L,ans=0;//闭区间，现在我比较习惯于写闭区间，但是要注意与下面对应 while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1;//位运算加速 int sum=work(mid); if(sum&gt;n) r=mid-1; else ans=max(ans,mid),l=mid+1;//mid有可能是答案 &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Conclusion 以前对于而二分的认识不明确，这一题是一个很好的二分题，主体是二分答案，然后判断答案的可行性，一般优化都是在判断可行性时加一些技巧。while里面基本上固定。 一定要注意区间的端点。 课后修改分析： 对于每一个mid值，都可以判断在移走不超过m块石头的情况下能不能完成目标。对于所有mid&gt;ans的情况，需要移走的石头总是&gt;m的，f(mid)=0；对于所有mid&lt;ans的情况，需要移走的石头总是&lt;=m的，f(mid)=1；这就有点像分教室，符合单调性。 临界值ans可以找到。 修改代码，我所有的二分都写的是中途更新ans，改成最后确定区间会比较好，对于所有&lt;=l的解，f(mid)=1，对于所以&gt;=r的解，f(mid)=0。 1234567int l=0,r=L+1;while(l+1&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(work(mid)) l=mid; else r=mid;&#125;cout&lt;&lt;l&lt;&lt;endl;","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"}]},{"title":"光荣的梦想(已批阅)","date":"2018-08-16T15:23:44.000Z","path":"2018/08/16/光荣的梦想/","text":"Problem 问题描述 Prince 对他在这片大陆上维护的秩序感到满意，于是决定启程离开艾泽拉斯。在他动身之前，Prince决定赋予King_Bette最强大的能量以守护世界、保卫这里的平衡与和谐。在那个时代，平衡是个梦想。因为有很多奇异的物种拥有各种不稳定的能量，平衡瞬间即被打破。KB决定求助于你，帮助他完成这个梦想。 一串数列即表示一个世界的状态。 平衡是指这串数列以升序排列。而从一串无序序列到有序序列需要通过交换数列中的元素来实现。KB的能量只能交换相邻两个数字。他想知道他最少需要交换几次就能使数列有序。 输入格式 第1行为数列中数的个数n（n &lt;= 100000） 第2行为n个数（绝对值不超过100000）。表示当前数列的状态。 输出格式 输出一个整数，表示最少需要交换几次能达到平衡状态。 Analysis 这题如果不是杨老师上课讲过，我可能不会想到求逆序对。 题目中两个条件暗示了逆序对：1.只能交换相邻两个数字 2.交换次数最少。 最开始我们求逆序对是冒泡排序，每一对进行比较，如果前一个大于后一个就交换，最后交换总次数就是逆序对个数。 但是这种算法复杂度是n^2的，很明显本题并不适用。 我们之后学习的是用归并排序解决逆序对，思路如下： 两个数列填入数字，如果当前填入前一个数列中数字，逆序对个数就等于后一个数列已经填入的数字个数。 因为我们保证填入数字是有序的，所以前一个数列与后一个数列已经填入的数字必然都存在逆序关系。 以上是mergesort方法，code如下123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;long long ans=0;int a[100010],t[100010],n;void mergesort(int t[],int a[],int l,int r)&#123; if(l&lt;r)&#123;//二分区间 int mid=(l+r)/2; mergesort(t,a,l,mid); mergesort(t,a,mid+1,r); int id1=l,id2=mid+1,cnt=l;//id是指当前两组数列中指针位置，cnt是待更新数组的指针位置 while(id1&lt;=mid||id2&lt;=r)//可以更新 if(id2&gt;r||(id1&lt;=mid&amp;&amp;a[id1]&lt;=a[id2])) &#123;//填入数列1，要记住是后面&lt;=，因为逆序对要前面大于后面 t[cnt++]=a[id1++]; ans+=id2-(mid+1);//累加逆序对 &#125; else t[cnt++]=a[id2++];//直接填入第二组数字 for(int i=l;i&lt;=r;i++) a[i]=t[i];//这里单独开一个数组，因为为了防止a数组错乱。 &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; mergesort(t,a,1,n);//闭区间，也可转为左闭右开 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 以上就是归并排序求逆序对的做法。 下面说一下用排序二叉树求逆序对。 其实只要懂了排序二叉树基本写法，这个还是很容易的。 在每一次插入数字时，计算出大于它的数字有多少个，分几种情况。 1.等于当前节点，返回右子树节点数； 2.大于当前节点，如果当前节点没有右子树就添加，否则继续搜索右子树； 3.小于当前节点，先把答案加上父亲节点的右子树节点数，然后搜索左子树，如果没有左子树就添加。 通过上面的分析，只需要在结构体里面多存一个sum用来记录当前节点的子节点数（包括本身）即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int data,sum,lft,rgt;//data点权，sum子节点数（包括自己）&#125;tree[80010];int n,js=0;long long ans=0;long long insert(int root,int k)&#123; long long ans=0; if(tree[root].data==k) &#123; ans=tree[tree[root].rgt].sum;tree[root].sum++;return ans;&#125;//情况1 if(tree[root].data&gt;k)&#123;//情况2 if(tree[root].lft!=0)&#123; ans+=tree[root].sum-tree[tree[root].lft].sum;//右子树节点 ans+=insert(tree[root].lft,k);//搜索左子树 &#125; else &#123; ans=tree[root].sum;//增加左子树 tree[++js].sum=1; tree[js].data=k; tree[js].lft=tree[js].rgt=0; tree[root].lft=js; &#125; &#125; if(tree[root].data&lt;k)&#123; if(tree[root].rgt!=0) ans=insert(tree[root].rgt,k);//直接搜索右子树 else &#123;//添加右子树 tree[root].rgt=++js; tree[js].lft=tree[js].rgt=0; tree[js].data=k; tree[js].sum=1; &#125; &#125; tree[root].sum++;//最后在加，防止重复计算 return ans;&#125;int main()&#123; cin&gt;&gt;n; int t; cin&gt;&gt;t; tree[1].data=t; tree[1].lft=tree[1].rgt=0; tree[1].sum=1; js=1; for(int i=2;i&lt;=n;i++) &#123; cin&gt;&gt;t; ans+=insert(1,t); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"},{"name":"排序二叉树","slug":"排序二叉树","permalink":"http://copenlife.top/tags/排序二叉树/"}]},{"title":"FBI树(已批阅)","date":"2018-08-16T15:23:20.000Z","path":"2018/08/16/FBI树/","text":"Problem 问题描述 我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。 FBI树是一种二叉树[1]，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下： 1.T的根结点为R，其类型与串S的类型相同； 2.若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。 现在给定一个长度为2N的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历[2]序列。 输入格式 第一行是一个整数N（0 &lt;= N &lt;= 10），第二行是一个长度为2N的“01”串。(3 10001011) 输出格式 包括一行，这一行只包含一个字符串，即FBI树的后序遍历序列。(IBFBBBFIBFIIIFF) Analysis 这题是分治，其实也有点像线段树，因为这是一棵满二叉树。 如果要求[i,j]，就必须先求出[i,(i+j)/2]和[(i+j)/2+1,j]，所以一直二分区间直到i=j。 因为数据范围很小，所以每次都将区间内所有字母都枚举一遍，判断输出即可。 题目要求输出后序遍历，就按照根左右顺序输出就好了。 Code O(n·logn))123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;string st;int n;int cnt=0;void dfs(int l,int r)&#123;//闭区间 if(r&gt;l)&#123;//有子树 dfs(l,(l+r)/2); dfs((l+r)/2+1,r); &#125; int sum=0; for(int i=l;i&lt;=r;i++) if(st[i]=='1') sum++; if(sum==r-l+1) cout&lt;&lt;\"I\";//判断 else if(sum==0) cout&lt;&lt;\"B\"; else cout&lt;&lt;\"F\"; return;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;st; dfs(0,st.size()-1); cout&lt;&lt;endl; return 0;&#125; 课后修改程序实现比较冗杂，可以进行修改，把程序设计成有返回值的。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;string st;int n;int dfs(int l,int r)&#123; int a,b; if(r&gt;l)&#123; a=dfs(l,(l+r)/2); b=dfs((l+r)/2+1,r); &#125; else a=b=st[l]-'0'; if(a!=b||(a==b&amp;&amp;b==2)) &#123;cout&lt;&lt;\"F\";return 2;&#125; else if(a==1) &#123;cout&lt;&lt;\"I\";return 1;&#125; else &#123;cout&lt;&lt;\"B\";return 0;&#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;st; dfs(0,st.size()-1); cout&lt;&lt;endl; return 0;&#125;","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"},{"name":"树结构","slug":"树结构","permalink":"http://copenlife.top/tags/树结构/"}]},{"title":"循环比赛(已批阅)","date":"2018-08-16T15:23:11.000Z","path":"2018/08/16/循环比赛/","text":"Problem 问题描述 设有n个选手进行循环比赛，其中n = 2m，要求每名选手要与其他n-1名选手都赛一次，每名选手每天比赛一次，循环赛共进行n - 1天，要求每天没有选手轮空。 样例输入 3 样例输出 1 2 3 4 5 6 7 8 2 1 4 3 6 5 8 7 3 4 1 2 7 8 5 6 4 3 2 1 8 7 6 5 5 6 7 8 1 2 3 4 6 5 8 7 2 1 4 3 7 8 5 6 3 4 1 2 8 7 6 5 4 3 2 1 Analysis 这道题一开始我觉得很像一个找规律的题目，然而我并没有看出它与分治有什么关系。 后来自己在纸上模拟了一遍填图的过程，想出了一种最暴力的方法，先把第一行按照1-2^n的顺序填好，之后每一行每一位都进行循环找到第一个可以与之相匹配的数字填入。后来发现这种方法其实没有想象中那么好写，因为状态更新比较复杂。 又盯着图看了好久，想到了行列关系和各种有规律的填图过程，发现了一种填图方法，满足自上而下从左到右的关系： 我们发现每一个2^k • 2^k的矩形，都是左上移到右下，右上移到左下。 比如a[1][1]=a[2][2],a[1][2]=a[2][1]，这是2*2的矩形，其他亦如此。 计算方法不太好描述，按照我程序写的自己手动填一下就知道了。 Code O(n^4)1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n,ans[210][210];void work(int k,int len)&#123;//k纵坐标起点，len是边长的一半 int s=len*2+1;//我找的一个规律，对于k=1，ans[i][j]=ans[边长+1-i][边长+1-j]，因为k不一定是1，所以直接往后调整就行了 for(int i=1;i&lt;=len;i++) for(int j=1;j&lt;=len*2;j++) ans[s-i][s-j+k-1]=ans[i][j+k-1];&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=(1&lt;&lt;n);i++) ans[1][i]=i; int k=1; for(int i=1;i&lt;=n;i++)&#123;//j枚举计算次数 for(int j=1;j&lt;=(1&lt;&lt;n);j+=k*2)//矩形左上方顶点的纵坐标，横坐标不用枚举，永远都是1 work(j,k); k*=2; &#125; for(int i=1;i&lt;=(1&lt;&lt;n);i++)&#123; for(int j=1;j&lt;=(1&lt;&lt;n);j++)&#123; cout&lt;&lt;ans[i][j]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"},{"name":"数学","slug":"数学","permalink":"http://copenlife.top/tags/数学/"}]},{"title":"幂取模（已批阅）","date":"2018-08-12T07:49:24.000Z","path":"2018/08/12/幂取模/","text":"Problem 问题描述 求a的b次方模k的值，a,b及k*k均是小于231的正整数。 输入描述 一行，三个用空格隔开的整数，a, b, k（2 10 7) 输出描述 输出结果：a^b mod k = 余数（2^10 mod 7=2） Analysis 就是一个快速幂。在此简单说明一下快速幂原理。 a^b = a · a · … · a (b个a) a^b = a^x1 · a^x2 · … · a^xn (x1+x2+…+xn=b) 运用二进制很容易求出x1,x2…xn， 例：2^10 （10在二进制下是1010） 2^10 = 2^2 · 2^8 = 2^(2 ^ 1) · 2^(2 ^ 3); 所以只需要在拆分二进制时，判断x%2是否为1，为1就把a^(2 ^ x)乘上即可。 过程中要不断累乘2^x%k。 Code：O(log n)123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;long long a,b,k;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;k; cout&lt;&lt;a&lt;&lt;\"^\"&lt;&lt;b&lt;&lt;\" mod \"&lt;&lt;k&lt;&lt;\"=\"; long long ans=1; while(b&gt;0)&#123; if(b&amp;1) ans=ans*a%k;//二进制中数字为1 a=a*a%k;//a每次都累乘 b=b&gt;&gt;1;//b就是被拆分的数字 &#125; cout&lt;&lt;ans%k&lt;&lt;endl; return 0; &#125; Conclusion 标程，理解背诵。","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"},{"name":"数学","slug":"数学","permalink":"http://copenlife.top/tags/数学/"},{"name":"二进制","slug":"二进制","permalink":"http://copenlife.top/tags/二进制/"}]},{"title":"方程求解(已批阅)","date":"2018-08-12T07:15:11.000Z","path":"2018/08/12/方程求解/","text":"Problem 问题描述 有形如：ax^3 + bx^2 + cx + d = 0 这样的一个一元三次方程。 输入描述 给出该方程中各项的系数(a，b，c，d 均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值&gt;=1。 输出描述 要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。提示 记方程f(x)=0，若存在2个数x1和x2，且x1&lt;x2，f(x1)*f(x2)&lt;0，则在(x1，x2)之间一定有一个根。 Analysis 这道题因为有了提示和限制条件而变得简单。 一开始不懂为什么两个根相差大于等于1，后来才知道这是帮我们减少了枚举范围。 我们只需要把（-100，100）划分成200个不同的区间，每个区间相差1，在每一个有可能出现解的区间里做运算即可。如果没有限制条件，一个区间内可能会有多解，这就会增加二分难度。 课后修改二分性质分析： 单调性：这是一个三次函数，在我的数学知识涉猎内不能保证单调性，但是题目中说明两个答案之间相差至少为1，所以在一个长度为1的区间内，只有一个解。 连续性：对于任意一个x,都有一个函数值与之对应。 Code：log(200 * logn)123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;double a,b,c,d;double f(double x)&#123; return a*x*x*x+b*x*x+c*x+d; &#125;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; for(int i=-100;i&lt;=100;i++)&#123; double l=i,r=i+1; double fl=f(l),fr=f(r); if(!fl) printf(\"%.2lf \",l);//这里不能判断fr，因为之后我们会枚举到r，这样会重复 else if(fl*fr&lt;0) &#123; while(r-l&gt;=0.001)&#123;//二分 double mid=(l+r)/2; double fmid=f(mid); if(fl*fmid&lt;0) r=mid,fr=fmid; else l=mid,fl=fmid;//这里就保证最后输出的结果一定是l。 &#125; printf(\"%.2lf \",l); &#125; &#125; return 0;&#125;/*一开始写错了两个地方，一个是没有事先判断fl是否为0，这就会导致最后结果出错。另外一开始TLE，我是很不理解的，但是后来检查一遍程序，发现我居然把mid定义成了int，罪过啊。 Conclusion像这种类型不是整型的题目，一定要注意不能把类型定义错。 二分的时候我觉得最容易出错的就是边界，所以边界一定得事先考虑清楚。","categories":[{"name":"分治算法初步","slug":"分治算法初步","permalink":"http://copenlife.top/categories/分治算法初步/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://copenlife.top/tags/分治/"}]},{"title":"最大乘积","date":"2018-08-12T01:52:25.000Z","path":"2018/08/12/最大乘积/","text":"Problem 题目描述 一个正整数一般可以分为几个互不相同的自然数的和，如3=1+2，4=1+3，5＝1+4=2+3，6=1+5＝2+4…。现在你的任务是将指定的正整数n分解成若干个互不相同的自然数的和，且使这些自然数的乘积最大。输入描述 只一个正整数n，(3≤n≤10000)。 输出描述 第一行是分解方案，相邻的数之间用一个空格分开，并且按由小到大的顺序。第二行是最大的乘积。 Analysis 其实一开始我有一个错误的思路，因为一个数字分成两个数相乘，根据正方形定则，两个数差值越小乘积越大，所以我就想把一个数一直除2，直到最后只剩一个2 (1·1&lt;2)。这样题目中的样例：10=2+3+5 是可以实现的，果然，样例最坑人。因为拆分出来的5也可以分成2·3啊，但是题目又要求不能是重复数字，此方法成功被推翻。也可以举一个反例：12=2+3+7 ，按照我的就是12=1+2+3+6, 明显错了。。。 所以需要进行下一种方法，正方形定则是个好东西，他帮助我想到了下一种方法，因为n·(n+1) &gt; (n-1)·(n+2)，就是正方形定则，所以我们只要找到一串相邻的数字乘就好了，1不需要，因为其他任何一个数字加1乘积都会更大，所以从2开始。 但是我们很难保证这样的数列最后和一定是n。我的方法是加到小于n的最大值为止。 剩余的数字如何处理？ 为了保证递增且相邻的法则，我们一定是把一串数字都加1，很容易看出从小往大加乘积会大得更多，但是这样不能保证数字不重复，所以我们只能从大往小加。 最后，加一个高精度即可。 Code ：O(n+n·len)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;struct bigint&#123;//和国王游戏一模一样的高精度，不多解释 int len,num[4010]; bigint operator = (bigint x)&#123; len=x.len; for(int i=0;i&lt;len;i++) num[i]=x.num[i]; return *this; &#125; bigint operator = (int x)&#123; len=0; memset(num,0,sizeof(num)); while(x&gt;0)&#123; num[len++]=x%10; x/=10; &#125; &#125; bigint operator * (int x)&#123; bigint ans; memset(ans.num,0,sizeof(ans.num)); ans.len=len; for(int i=0;i&lt;len;i++) ans.num[i]=num[i]*x; int last=0; for(int i=0;i&lt;len;i++)&#123; ans.num[i]+=last; last=ans.num[i]/10; ans.num[i]%=10; &#125; while(last&gt;0) ans.len++,ans.num[ans.len-1]=last%10,last/=10; return ans; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; out,bigint x)&#123; for(int i=x.len-1;i&gt;=0;i--) out&lt;&lt;x.num[i]; return out; &#125;&#125;;int n;int num[1010],cnt=0;int main()&#123; cin&gt;&gt;n; if(n==1) &#123; cout&lt;&lt;\"1\"&lt;&lt;endl&lt;&lt;\"1\"; return 0;&#125; int sum=0; for(int i=2;sum+i&lt;=n;i++) num[cnt++]=i,sum+=i;//这里是把前面所有连续数字算出来 sum=n-sum;//剩余的数字分成1加到之前数字上 for(int i=1;i&lt;=sum;i++) num[cnt-i]++; for(int i=0;i&lt;cnt;i++) cout&lt;&lt;num[i]&lt;&lt;\" \"; cout&lt;&lt;endl; bigint ans; ans=num[0]; for(int i=1;i&lt;cnt;i++) ans=ans*num[i]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Conclusion: 一般贪心的题目都是考虑当前的选择，比如这一题只要得到n·(n+1)&gt;(n-1)·(n+2)这一个式子，就可以做出当前的选择，并且决定最终的结果。","categories":[{"name":"贪心算法基础","slug":"贪心算法基础","permalink":"http://copenlife.top/categories/贪心算法基础/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://copenlife.top/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"http://copenlife.top/tags/贪心/"}]},{"title":"About Reputation","date":"2018-08-11T14:50:31.000Z","path":"2018/08/11/Reputation记录/","text":"第一次经历发专辑全过程Album 2006 《Taylor Swift》 2008 《Fearless》 2010 《Speak now》 2012 《Red》 2014 《1989》 2017 《Reputation》 1. Look What You Made Me Do2017.8.25记不清具体的时间了，上网查了一下发现是2017.8.25，其实当时我已经开学了，然后中午回家第一件事就是听LWYMMD，当时用的是网易云，看了评论发现网友已经把这首歌取名为咪咪兔（后来不常用了）。 我第一次听这首歌并没有喜欢上，因为风格不一样。我依旧喜欢1989和之前的乡村，所以并没有接受这首，但毕竟我知道这专封面就已经和以往风格不同，所以逐渐听着也就习惯了，不过直到现在，我听这个还是有些压抑啊 [捂脸哭泣]。 当时喜欢的是这首歌的MV，看了好多遍也看不腻，觉得MV拍的甚合我意。最喜欢里面的那句The old can’t come to the phone right now，很酷啊哈哈哈哈。 2. …Ready For It?2017.9.4这首是越听越爱，写这篇文章时我还在听。 作为专辑第二首发布的曲目，有了第一首的参考，也没有那么惊诧，反而有些好听，让我想起了《Bad blood》的节奏。 刚开始没注意，这里引用别人的评论： 咪咪兔：MMP我不要面子的啊，鱼贝贝(…Ready for it?)不管是10秒的清嗓子，还是56秒和2分02秒的mmm，还是2分20的娇喘，都让人欲罢不能啊啊啊啊！！！！ 想知道更多自己去听吧。 这首歌的MV我不是那么喜欢，因为太科技化了，MV我还是喜欢以前的风格。说实话，这专的MV暂时出来的(差不多是全部的了)，我最喜欢Delicate。雨中跳舞和一开始镜子里的镜头太美啦。 3.Gorgeous2017.10.20距离上一首出来已经过去一个多月了。这首出来没太在意还是同学告诉我的。 不过Gorgeous真的很好听耶，第一秒就爱上了它。当时我超级兴奋，听了好多遍。 但是这首好像没什么可以写的，喜欢就对了。 Call It What You Want2017.11.3就我个人而言，前四首我非常喜欢这首，有图为证：这是网易云上的一个记录，其实当天好像是我睡觉忘记摘耳机了，不过由此可见我爱这首的程度。 第一次听这首心情就很柔和，因为曲调很轻松，声音有心动的感觉 (,,• ₃ •,,)。 — Would you run away with me? — Yes. 行到水穷处，坐看云起时. 上面就是Rep的四首先行曲。我觉得这几首也几乎涵盖了本专的几种风格。 如果说后续，就是11.10正式发行了。当时我正在前往南京参加可爱的NOIP。就在中午13点左右，网易qq都上线了，然鹅当时的我手机性能比较渣，是2G网络，导致没能听成。不过我们宿舍可爱的马妈妈用电脑放给我们听，当时她放了好久的Delicate，我也觉得那首很好听，所以回来后听的第一首就是它。而且脆皇真的十分受宠啊，那么多MV，演唱会还有单独的蛇骨吊篮。 今年5月，是Reputation Stadium Tour开始的时间，那天我看了整整一个中午ins和微博上的各种视频，会有种莫名的感动，就是那种很想立刻冲去USA的感觉。然后我就想这以后一定要去一次Tayd的world tour，如果我无比幸运的拿到小房间通行证，此生无憾（我觉得在国外拿到的可能性比较大，因为那样我就相当于外国人远渡重洋来到这儿了啊）。 以上，是我与Rep相遇的那些事。 这里写一下我对此专歌曲的喜爱程度（个人见解）： 首先我要声明，都很好听。 除了上面的第一名，下面名单如下 这里没有《King of my heart》, 《Look what you made me do》, 《New Year’s Day》, 《Don’t Blame Me》, 《I did something bad》, 《So it goes》和《This is why we can’t have nice things》. 其实这几首也很好听，实际意义上我不太常听的只有《Look what you made me do》和《This is why we can’t have nice things》，其他几首我也是会经常听的。 全专里面我一开始很喜欢《Getaway Car》《Delicate》和《Call it what you want》，其实这几首风格相近。 后来越听越有感觉的是《…Ready For It?》《Dancing With Our Hands Tied》和《End Game》，这几首的风格，也是相近的。 所以我听音乐可能真的是一段时间一个心情，一个风格。 不过不管什么心情，什么风格，老霉的都会很喜欢。 最后放上一些日常看到的图片，直接搜索不一定能找到，因为大部分是我平常在微博上看到存下来的，算是比较不寻常了。 这些都是演唱会的一些图片 这些是小泰同学最近一些街拍，我很满意尤其是第一套的第一张，仙女下凡来啦。 就写这么多了吧。 之后会陆续更新一些其他的小故事。 Written by Copen","categories":[{"name":"Taylor","slug":"Taylor","permalink":"http://copenlife.top/categories/Taylor/"}],"tags":[{"name":"Taylor","slug":"Taylor","permalink":"http://copenlife.top/tags/Taylor/"}]},{"title":"国王游戏","date":"2018-08-11T08:00:43.000Z","path":"2018/08/11/国王游戏/","text":"Problem 问题描述 恰逢 H 国国庆,国王邀请n位大臣来玩一个有奖游戏。首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。然后,让这n位大臣排成一排,国王站在队伍的最前面。排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是:排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果 国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。注意,国王的位置始终在队伍的最前面。 输入格式 第一行包含一个整数n,表示大臣的人数。第二行包含两个整数 a 和b,之间用一个空格隔开,分别表示国王左手和右手上的整数。接下来 n 行,每行包含两个整数 a 和 b,之间用一个空格隔开,分别表示每个大臣左手和右手上的整数。 输出格式 输出只有一行,包含一个整数,表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 Analysis: 因为我知道这是个贪心题，所以一开始就往这方面想了。 题目中让左手乘积除以右手数字，所以肯定是尽量让左手乘积小，右手数字大，这应该就涉及到某个关键字排序。 就如何排序这个问题，我陷入了沉思： 如果i排在j前面，我们可以知道： L[i]/R[j] &lt; L[j]/R[i] (约去前面的乘积后） 把这个式子化简一下，很容易得到：L[i]R[i] &lt; L[j]R[j]。 所以只需要按照左右手乘积从小到大排序就可以了。 这题还有一个点，由于数字最大是10000，最多有1000个，可以想象，10000^1000绝对是一个长整数，而且最长是4000位。重载运算符即可。 写重载运算符的时候，有一个地方一开始写错了，就是在去除前导0时，应该是返回值的长度变小，我把一开始的数字长度减小了。 Code：O(n·len)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int l,r;&#125;a[1010];struct bigint&#123; int len,num[4010]; bigint operator = (int x)&#123;//这是一开始赋值 len=0; while(x&gt;0)&#123; num[len++]=x%10; x/=10; &#125; return *this; &#125; bigint operator = (bigint x)&#123;//大整数标配 len=x.len; for(int i=0;i&lt;len;i++) num[i]=x.num[i]; return *this; &#125; bigint operator * (int x)&#123;//大整数乘大整数见标程，这里写个简化版的(不容易错hhhhhh) bigint ans; memset(ans.num,0,sizeof(ans.num)); ans.len=len; for(int i=0;i&lt;ans.len;i++) ans.num[i]=num[i]*x; int last=0; for(int i=0;i&lt;len;i++)&#123; ans.num[i]+=last; last=ans.num[i]/10; ans.num[i]%=10; &#125; while(last) ans.len++,ans.num[ans.len-1]=last%10,last/=10;//就是这儿一开始写错了，写成了len--。。。然后就WA return ans; &#125; bigint operator / (int x)&#123;//其实如果一个大整数除以一个大整数，我是不会写的，这里是简化版，大整数除以整数 bigint ans; memset(ans.num,0,sizeof(ans.num)); ans.len=len; int last=0; for(int i=len-1;i&gt;=0;i--)&#123; ans.num[i]=(last*10+num[i])/x; last=(last*10+num[i])%x; &#125; while(!ans.num[ans.len-1]&amp;&amp;ans.len&gt;1) ans.len--;//同上，一开始写错了 return ans; &#125; bool operator &gt; (bigint x)&#123;//判断大小，因为答案可能中途更新 if(len&gt;x.len) return true; if(len&lt;x.len) return false; for(int i=len-1;i&gt;=0;i++)&#123; if(num[i]&gt;x.num[i]) return true; if(num[i]&lt;x.num[i]) return false; &#125; return false; &#125; string str()&#123;//大整数转换成字符串标配 string ans=\"\"; for(int i=len-1;i&gt;=0;i--) ans+=char(num[i]+'0'); return ans; &#125; friend ostream&amp; operator &lt;&lt;(ostream&amp; out,bigint x)&#123;//输出标配 out&lt;&lt;x.str(); return out; &#125;&#125;; int n;bigint ans,sum;bool cmp (node p,node q)&#123; return p.l*p.r&lt;q.l*q.r;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) cin&gt;&gt;a[i].l&gt;&gt;a[i].r; sort(a+1,a+n+1,cmp); sum=a[0].l;//上面写两个“=”就在这里用上了 for(int i=1;i&lt;=n;i++)&#123; bigint x=sum/a[i].r; if(x&gt;ans) ans=x; sum=sum*a[i].l; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Conclusion: 两个大整数乘除找个时间写了吧，放到文件里。","categories":[{"name":"贪心算法基础","slug":"贪心算法基础","permalink":"http://copenlife.top/categories/贪心算法基础/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://copenlife.top/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"http://copenlife.top/tags/贪心/"}]},{"title":"Red - Taylor Swift","date":"2018-08-10T16:00:00.000Z","path":"2018/08/11/Meet Taylor/","text":"此生最爱 RedAlbum 2006 《Taylor Swift》 2008 《Fearless》 2010 《Speak now》 2012 《Red》 2014 《1989》 2017 《Reputation》 第一次听到《Red》其实是别人的翻唱，这个不重要。 重要的是，在翻唱的弹幕里面清一色的评论没有原唱好听，正因这样，我通过一个十八线小网红认识了Tay并成功爱上了这个女人（胖瘦都爱）。当时我就在音乐软件上搜索了一下Taylor Swift，软件介绍图片是这一张: 这张图片真的非常好看，当时觉得这一定是小仙女。而且Taylor真的太适合红唇了。 其实这已经是89时期了，所以说我认识泰勒认识的晚嘛 ╮(╯▽╰)╭。 但是一点开收听发现是要付费的，当时穷苦的我一开始不准备开通服务。但是后来听了好多遍翻唱，实在是超级想听原唱啊。于是这次我毫不犹豫，开通了一个月的服务。 所以，我听过泰勒的第一首就是《Red》，多么奇妙的缘分，我至今最喜欢的还是这一首，手机铃声是这一首，答应唱给别人听的是这一首，在全班同学面前一个人唱过的也是这一首，当然最后一个是黑历史（不愿重提）。 因而我决定把Red作为Life中的第一页，Red的词像我这个年纪还是不太懂的，毕竟是爱情。 在这里附上几张张姨妈时期的old Taylor，一张Red Tour的图片，以及我曾经买过的实体专Red，第一次买专辑其实也是为了给别人当生日礼物。 其实我的PC里面存了好多images(・`ω´･)。 新年的时候，我还在ins和twitter上send messages to Taylor 现在想想还是很开心啊 Pictures 这两张很适合Wallpaper。 这三张有些没有诚意了，为了清晰所以我就直接从百度上找的。 Red tour in Shanghai，但是我没有去啊，那时候刚认识Taylor还没有现在这样喜欢。 这是我给别人的surprise，其实自己也很激动啦，所以我也给自己一张《1989》和一份reputation的target (・ω・=)，现在想想居然还有些激动。所以在此我就不知羞耻的放上两张图： 请自动忽略背景，没记错应该是历史中考复习指南，想想那个时候的自己，感觉时间过得也太快了吧。 另外附上Red的歌词。 Lyric Loving him is like driving a new Maserati down a dead end street Faster than the wind, passionate as sin, ending so suddenly Loving him is like trying to change your mind once you’re already flying through the free fall Like the colors in autumn so bright just before they lose it all Losing him was blue, like I’d never known Missing him was dark gray, all alone Forgetting him was like trying to know somebody you never met But loving him was red Loving him was red Touching him was like realizing all you ever wanted was right there in front of you Memorizing him was as easy as knowing all the words to your old favorite song Fighting with him was like trying to solve a crossword and realizing there’s no right answer Regretting him was like wishing you never found out that love could be that strong Losing him was blue, like I’d never known Missing him was dark gray, all alone Forgetting him was like trying to know somebody you’ve never met But loving him was red, oh red, burning red Remembering him comes in flashbacks and echoes Tell myself it’s time now gotta let go But moving on from him is impossible when I still see it all in my head… in burning red Burning, it was red Losing him was blue, like I’d never known Missing him was dark gray, all alone Forgetting him was like trying to know somebody you’ve never met Cause loving him was red, yeah yeah red, burning red And that’s why he’s spinning around in my head Comes back to me in burning red Loving him is like driving a new Maserati down a dead end street 下一篇决定写Reputation Written by Copen","categories":[{"name":"Taylor","slug":"Taylor","permalink":"http://copenlife.top/categories/Taylor/"}],"tags":[{"name":"Taylor","slug":"Taylor","permalink":"http://copenlife.top/tags/Taylor/"}]}]