<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>借教室(已批阅) | Mercury</title>
  <meta name="author" content="Copen">
  
  <meta name="description" content="Problem from NOIP2012T

问题描述
　　在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="借教室(已批阅)"/>
  <meta property="og:site_name" content="Mercury"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Mercury" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Mercury</a></h1>
  <h2><a href="/">Always like this.</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-08-17T15:21:45.000Z"><a href="/2018/08/17/借教室/">2018-08-17</a></time>
      
      
  
    <h1 class="title">借教室(已批阅)</h1>
  

    </header>
    <div class="entry">
      
        <p><strong>Problem from NOIP2012T</strong></p>
<blockquote>
<p><em>问题描述</em></p>
<p>　　在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p>
<a id="more"></a>
<p>　　面对海量租借教室的信息，我们自然希望编程解决这个问题。</p>
<p>　　我们需要处理接下来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为dj,sj,tj，表示某租借者需要从第sj天到第tj天租借教室（包括第sj天和第tj天），每天需要租借dj个教室。</p>
<p>　　我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p>
<p>　　借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教室数量不足dj个。</p>
<p>　　现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p>
<p><em>输入格式</em></p>
<p>　　第一行包含两个正整数n,m，表示天数和订单的数量。</p>
<p>　　第二行包含n个正整数，其中第i个数为ri，表示第i天可用于租借的教室数量。</p>
<p>　　接下来有m行，每行包含三个正整数dj,sj,tj，表示租借的数量，租借开始、结束分别在第几天。<br>　　每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。</p>
<p><em>样例输入</em></p>
<p>4 3</p>
<p>2 5 4 3</p>
<p>2 1 3</p>
<p>3 2 4</p>
<p>4 2 4</p>
<p><em>输出格式</em></p>
<p>如果所有订单均可满足，则输出只有一行，包含一个整数0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。</p>
<p><em>样例输出</em></p>
<p>-1</p>
<p>2</p>
</blockquote>
<p><strong>Analysis</strong></p>
<p>上课的线段树例题，不过线段树模板忘得差不多了，还是去看看之前写的才想起来。</p>
<p>结构体用minv记录[l,r]之间的最小值，用一个lazy标记或用标记永久化(效率更高)。</p>
<p>首先建树，build_tree(1,1,n)</p>
<p>然后每次读入后，把相应的区间修改(-1)，最后返回根节点的minv，如果minv &lt; 0,就说明至少有一天的状态不合法了，就直接输出-1。</p>
<p><strong>Code (lazy 标记版)</strong></p>
<p>由于每次lazy标记都要向下传递，是一个常数的运算，所以在大数据时会被卡，不过日常解决线段树还是不二之选</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> minv,lft,rgt,lazy;</span><br><span class="line">&#125;a[MAXN*<span class="number">4</span>+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//建树</span></span><br><span class="line">    a[r].lft=x,a[r].rgt=y;</span><br><span class="line">    <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">        a[r].minv=num[x];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(x+y)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build_tree(r*<span class="number">2</span>,x,mid),build_tree(r*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,y);</span><br><span class="line">        a[r].minv=min(a[r*<span class="number">2</span>].minv,a[r*<span class="number">2</span>+<span class="number">1</span>].minv);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    a[r].minv-=a[r].lazy;</span><br><span class="line">    a[r*<span class="number">2</span>].lazy+=a[r].lazy,a[r*<span class="number">2</span>+<span class="number">1</span>].lazy+=a[r].lazy;</span><br><span class="line">    a[r].lazy=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    push(r);<span class="comment">//一开始一定要先push，把上一次的标记更新一下，不然之后可能会被清掉</span></span><br><span class="line">    <span class="keyword">int</span> lft=a[r].lft,rgt=a[r].rgt;</span><br><span class="line">    <span class="keyword">if</span>(lft&gt;=x&amp;&amp;rgt&lt;=y)&#123;</span><br><span class="line">        a[r].lazy+=k;</span><br><span class="line">        push(r);</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//记得return，不然lazy标记在以后会被重复更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lft&gt;y||rgt&lt;x) <span class="keyword">return</span>;</span><br><span class="line">    update(r*<span class="number">2</span>,x,y);</span><br><span class="line">    update(r*<span class="number">2</span>+<span class="number">1</span>,x,y);</span><br><span class="line">    a[r].minv=min(a[r*<span class="number">2</span>].minv,a[r*<span class="number">2</span>+<span class="number">1</span>].minv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) num[i]=read();</span><br><span class="line">    build_tree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y ;</span><br><span class="line">        k=read(),x=read(),y=read();</span><br><span class="line">        update(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>].minv&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就是srz给我介绍的标记永久化，定理比较复杂，我真的不知道如何阐述，复制一下：</p>
<blockquote>
<p>原理就是： 在路过该节点的时候把修改对答案的影响加上，来省去标记下放的过程</p>
</blockquote>
<p>自我理解（完全凭感觉）：</p>
<p>想象一下，当前的minv是子树更新来的，也就是当时没有lazy标记但是可能修改到当前的minv，而当前的lazy标记记录的是没有继续搜索的所有更新值，只要把当前的minv-lazy就可以得到目前的状态值。</p>
<p>举个例子：</p>
<p>修改[3,5],现在状态是[4,5],就不用再搜索，直接lazy++；</p>
<p>第二次修改[3,4],现在状态依旧是[4,5]，就需要继续搜索然后更新，而最终[4,5]这个状态的值应该是第二次修改过的-第一次的lazy标记。</p>
<p>我觉得应该就是这样的吧。</p>
<p><strong>Code (标记永久化)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> minv,lft,rgt,lazy;</span><br><span class="line">&#125;a[MAXN*<span class="number">4</span>+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) ch=getchar();</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//建树</span></span><br><span class="line">	a[r].lft=x,a[r].rgt=y;</span><br><span class="line">	<span class="keyword">if</span>(x==y)&#123;<span class="comment">//叶子节点</span></span><br><span class="line">		a[r].minv=num[x];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(x+y)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		build_tree(r&lt;&lt;<span class="number">1</span>,x,mid),build_tree(r&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,y);</span><br><span class="line">		a[r].minv=min(a[r&lt;&lt;<span class="number">1</span>].minv,a[r&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].minv);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	a[r].minv=min(a[r&lt;&lt;<span class="number">1</span>].minv-a[r&lt;&lt;<span class="number">1</span>].lazy,a[r&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].minv-a[r&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lft=a[r].lft,rgt=a[r].rgt;</span><br><span class="line">	<span class="keyword">if</span>(lft&gt;=x&amp;&amp;rgt&lt;=y)&#123;<span class="comment">//当前区间属于[x,y]</span></span><br><span class="line">		a[r].lazy+=k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lft&gt;y||rgt&lt;x) <span class="keyword">return</span>;</span><br><span class="line">	del(r&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">	del(r&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">	update(r);<span class="comment">//每次都要更新(下面全部更新完毕)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=read(),m=read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) num[i]=read();</span><br><span class="line">	build_tree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y ;</span><br><span class="line">		k=read(),x=read(),y=read();</span><br><span class="line">		del(<span class="number">1</span>,x,y);</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">1</span>].minv-a[<span class="number">1</span>].lazy&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一题的永久化还比较简单，因为最后只需要返回根的值，如果返回任意区间的值，需要写函数。把我从网上找的线段树标记永久化标程写一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//返回i区间和[l,r]的交集中的最小值</span></span><br><span class="line">   <span class="keyword">if</span>(l(i)&gt;r||r(i)&lt;l)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//没有交集，返回inf</span></span><br><span class="line">   <span class="keyword">if</span>(l(i)&gt;=l&amp;&amp;r(i)&lt;=r) <span class="keyword">return</span> ata(i)-minus(i);<span class="comment">//[l,r]包含i区间，直接返回i区间的最小值</span></span><br><span class="line">   <span class="keyword">return</span> min(query(i&lt;&lt;<span class="number">1</span>,l,r),query(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r))-minus(i);<span class="comment">//否则就往下搜索</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这题既然放在这里，还是要写一下二分的，二分答案，也就是第几天不能满足要求。只需要把之前的所有教室使用个数算出来，然后看有没有大于教室总数的，如果有返回false。</p>
<p>如果最后返回false，说明r=mid，反之l=mid;</p>
<p>因为每次枚举教室的使用不可能把[l,r]全部枚举，然后加1，所以我们可以用前缀和优化：</p>
<p>举个例子[l,r]=[2,5];</p>
<p>开始时数组 s[10]={0};</p>
<p>s[2]++,s[6]–;</p>
<p>数组变为 s[10]={0,0,1,0,0,0,-1,0,0,0,0};</p>
<p>此数组前缀和为 pre[10]={0,0,1,1,1,1,0,0,0,0};</p>
<p>这样就巧妙地用pre数组记录下了每天的使用情况。</p>
<p><strong>Code O(logm·(m+n))</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k,num[MAXN],pre[MAXN],t[MAXN],x[MAXN],y[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) ch=getchar();</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">		pre[x[i]]+=t[i],pre[y[i]+<span class="number">1</span>]-=t[i];<span class="comment">//其实我之前的s[],pre[]可以合并成一个。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]+=pre[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(pre[i]&gt;num[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=read(),m=read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) num[i]=read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) t[i]=read(),x[i]=read(),y[i]=read();</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=m,ans=inf;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;<span class="comment">//二分</span></span><br><span class="line">		<span class="keyword">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> ans=min(ans,mid),r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans==inf) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n%d\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Conclusion</strong>：</p>
<p>对于线段树lazy标记的使用不是特别清楚，迷迷糊糊的只能画图验证自己的猜想，还是要多写写多想想。</p>
<hr>
<h4 id="课后修改"><a href="#课后修改" class="headerlink" title=" 课后修改"></a><font color="Red"> 课后修改</font></h4><p>为何满足二分性质：</p>
<ul>
<li>如果存在解一定在1-m之间，比ans小的天数一定可以分配好教室，比ans大的天数一定无法分配教室。</li>
<li>1-m是离散点，每一个点都可以判断是否可行。</li>
<li>分析左右区间端点，l=0，所有小于l的都可行，r=m，如果有解，一定&lt;=r。但是这个地方老师说我这种写法不好，因为我做了很多无用的ans更新，这里可以这样修改一下（左闭右开）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">	<span class="keyword">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(check(mid)) l=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r==m+<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//说明所有都可行，r没有更新过</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//因为不可行才会更新r，所以&gt;=r的点都是不可行的，r就是解</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/分治算法初步/">分治算法初步</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/前缀和优化/">前缀和优化</a>, <a href="/tags/分治/">分治</a>, <a href="/tags/线段树/">线段树</a>, <a href="/tags/线段树优化/">线段树优化</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://copenlife.top/2018/08/17/借教室/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:copenlife.top">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Taylor/">Taylor</a><small>2</small></li>
  
    <li><a href="/categories/分治算法初步/">分治算法初步</a><small>10</small></li>
  
    <li><a href="/categories/动态规划初步/">动态规划初步</a><small>11</small></li>
  
    <li><a href="/categories/图的存储和遍历/">图的存储和遍历</a><small>4</small></li>
  
    <li><a href="/categories/实战测试/">实战测试</a><small>9</small></li>
  
    <li><a href="/categories/拓扑序与关键路径/">拓扑序与关键路径</a><small>3</small></li>
  
    <li><a href="/categories/树的存储和遍历/">树的存储和遍历</a><small>11</small></li>
  
    <li><a href="/categories/贪心算法基础/">贪心算法基础</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Taylor/">Taylor</a><small>2</small></li>
  
    <li><a href="/tags/lca/">lca</a><small>1</small></li>
  
    <li><a href="/tags/二分图/">二分图</a><small>1</small></li>
  
    <li><a href="/tags/二进制/">二进制</a><small>1</small></li>
  
    <li><a href="/tags/分治/">分治</a><small>10</small></li>
  
    <li><a href="/tags/前缀和优化/">前缀和优化</a><small>3</small></li>
  
    <li><a href="/tags/动态规划/">动态规划</a><small>12</small></li>
  
    <li><a href="/tags/动态规划优化/">动态规划优化</a><small>1</small></li>
  
    <li><a href="/tags/哈希表/">哈希表</a><small>1</small></li>
  
    <li><a href="/tags/图论/">图论</a><small>4</small></li>
  
    <li><a href="/tags/并查集/">并查集</a><small>1</small></li>
  
    <li><a href="/tags/拓扑排序/">拓扑排序</a><small>4</small></li>
  
    <li><a href="/tags/排序二叉树/">排序二叉树</a><small>1</small></li>
  
    <li><a href="/tags/数学/">数学</a><small>9</small></li>
  
    <li><a href="/tags/枚举/">枚举</a><small>2</small></li>
  
    <li><a href="/tags/树结构/">树结构</a><small>13</small></li>
  
    <li><a href="/tags/模拟/">模拟</a><small>1</small></li>
  
    <li><a href="/tags/状压/">状压</a><small>1</small></li>
  
    <li><a href="/tags/线段树/">线段树</a><small>1</small></li>
  
    <li><a href="/tags/线段树优化/">线段树优化</a><small>1</small></li>
  
    <li><a href="/tags/贪心/">贪心</a><small>3</small></li>
  
    <li><a href="/tags/随笔/">随笔</a><small>3</small></li>
  
    <li><a href="/tags/高精度/">高精度</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 Copen
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
