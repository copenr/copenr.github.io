<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>标签: 树结构 | Mercury</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Mercury">
<meta property="og:url" content="http://copenlife.top/tags/树结构/index.html">
<meta property="og:site_name" content="Mercury">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mercury">
  
    <link rel="icon" href="Always like this">
  
  <link rel="stylesheet" href="/css/index.css">
</head>

<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">Copen</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://github.com/copenr" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
          
            <a href="https://weibo.com/5254792241" target="_blank" class="nav-icn iconfont icon-weibo"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main">
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/24/X-magic/" class="title">Test3:小X的佛光</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>小 X所在的城市 X城是一个含有 N个节点的无向图，同时由于 X国是一 个发展中国家 ，为了节约城市建设的经费 ，X国首相在建造 X城时只建造 N – 1条边，使得城市的各个地点能够相互到达。<br>
</section>
    <p class="sub">9月 24, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/09/Next-tree/" class="title">下一棵树问题</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>农场上有N（1&lt;=N&lt;=1000）棵树。在上过计算机课后，Lin发现所有的树实际上都是严格的二叉树，二叉树的每个非叶结点都恰好有两个子结点，Lin给每个结点一个数表示以这个结点为根的子树的叶结点数。然后，Lin按照先序遍历的结果把和结点相关的数列出作为它的特征序列。但是，他只列出了与根结点和所有的左子结点相关的数。例如对图所示的树：<br>
</section>
    <p class="sub">9月 9, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/09/Symmetry-Tree/" class="title">对称二叉树</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>如果二叉树的左右子树的结构是对称的，即两棵子树皆为空，或者皆不空，则称该二叉树是对称的。编程判断给定的二叉树是否对称.<br>
</section>
    <p class="sub">9月 9, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/09/FBI-tree/" class="title">FBI树</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p><em>问题描述</em></p>
<p>我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。</p>
<p>FBI树是一种二叉树[1]，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：<br>
</section>
    <p class="sub">9月 9, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/05/Search-tree/" class="title">查找二叉树</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>　已知一棵二叉树用邻接表结构存储，中序查找二叉树中值为x的结点，并指出是第几个结点。例：如图二叉树的数据文件的数据格式如下<br>
</section>
    <p class="sub">9月 5, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/05/Print-tree/" class="title">二叉树输出</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>　树的凹入表示法主要用于树的屏幕或打印输出，其表示的基本思想是兄弟间等长，一个结点的长度要不小于其子结点的长度。二叉树也可以这样表示，假设叶结点的长度为1，一个非叶结点的长度等于它的左右子树的长度之和。<br>
</section>
    <p class="sub">9月 5, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/05/LDR-Level/" class="title">二叉树遍历</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>　输入一棵二叉树的中序遍历和按层遍历的序列，输出其先序遍历序列。<br>
</section>
    <p class="sub">9月 5, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/05/Small-ball/" class="title">小球</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>　许多的小球一个一个的从一棵满二叉树上掉下来组成FBT（Full Binary Tree，满二叉树），每一时间，一个正在下降的球第一个访问的是非叶子节点。然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。<br>
</section>
    <p class="sub">9月 5, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/05/Extend-tree/" class="title">扩展二叉树</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>由于先序、中序和后序序列中的任一个都不能唯一确定一棵二叉树，所以对二叉树做如下处理，将二叉树的空结点用“.”补齐，如图所示。<br><img src="http://www.tsinsen.com/RequireFile.do?fid=GGbGftbd" alt=""><br>
</section>
    <p class="sub">9月 5, 2018</p>
  </div>
</div>
  
    
    <div class="project-card project-card-continuous">
  
  <div class="ctnWrap">
    <a href="/2018/09/05/DLR-LDR/" class="title">求后序遍历</a>
    <section class="desc">
  <p><strong>Problem</strong></p>
<blockquote>
<p>　输入一棵二叉树(结点 &lt;= 100)的先序和中序遍历序列，输出其后序遍历序列。<br>
</section>
    <p class="sub">9月 5, 2018</p>
  </div>
</div>
  
  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/tags/树结构/page/2/">2</a><a class="extend next" rel="next" href="/tags/树结构/page/2/"><span class="iconfont icon-arrow-right"></span></a>
  </nav>


</div>
    <footer id="footer" class="f-cf">
  
  
    
      
        · <a href="https://github.com/copenr" target="_blank" class="nav-icn">GitHub</a>
      
    
      
        · <a href="https://weibo.com/5254792241" target="_blank" class="nav-icn">weibo</a>
      
    
  
  <span class="copyright">All rights reserved @Copen</span>
</footer>
  </div>
</body>
</html>